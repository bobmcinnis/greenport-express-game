<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Greenport Express — Line Art Pop</title>
<style>
  html,body{height:100%;margin:0}
  body{background:#ffffff;color:#111;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;cursor:crosshair}
  .wrap{position:fixed;inset:0}
  .scene{position:absolute;inset:0}
  .hud{
    position:absolute;left:50%;bottom:10px;transform:translateX(-50%);
    background:#fff;border:1px solid #111;border-radius:10px;padding:6px 10px;display:flex;gap:10px;align-items:center;z-index:2
  }
  .hud small{opacity:.7}
  #status{position:absolute;left:10px;top:10px;background:#fff;border:1px solid #111;border-radius:8px;padding:4px 8px;z-index:2}
</style>
</head>
<body>
<div class="wrap">
  <div id="status">Loading…</div>
  <div id="scene" class="scene" tabindex="0" aria-label="Game canvas"></div>
  <div class="hud"><strong>Score:</strong><span id="score">0</span><small>(Click or Space to shoot • Drag / ← → ↑ ↓ to look)</small></div>
</div>

<script src="./three.min.js"></script>
<script>
(function(){
  const setStatus = m => (document.getElementById('status').textContent = m);
  if(!window.THREE){ setStatus('ERROR: three.min.js not found next to index.html'); return; }
  const THREE = window.THREE;

  // --- Renderer / Scene / Camera ---
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
  renderer.setClearColor(0xffffff, 1);
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, 1, 0.05, 2000);
  scene.add(camera);

  function fit(){ const r=container.getBoundingClientRect(); const w=Math.max(1,r.width), h=Math.max(1,r.height);
    camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); }
  new ResizeObserver(fit).observe(container); fit();

  // --- Simple helpers ---
  const BLACK = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 1 });
  function lineCircle(r, seg=64){
    const g=new THREE.BufferGeometry(), pos=[];
    for(let i=0;i<=seg;i++){ const a=i/seg*Math.PI*2; pos.push(Math.cos(a)*r,0,Math.sin(a)*r); }
    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    return new THREE.Line(g, BLACK);
  }
  function lineRing(r1,r2, seg=64){
    const g=new THREE.BufferGeometry(), pos=[];
    for(let i=0;i<=seg;i++){ const a=i/seg*Math.PI*2; pos.push(Math.cos(a)*r1,0,Math.sin(a)*r1, Math.cos(a)*r2,0,Math.sin(a)*r2); }
    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    return new THREE.LineSegments(g, BLACK);
  }
  function lineRect(w,h){
    const hw=w/2, hh=h/2;
    const pts=[[-hw,0,-hh],[hw,0,-hh],[hw,0,hh],[-hw,0,hh],[-hw,0,-hh]];
    const g=new THREE.BufferGeometry(), pos=[]; for(let i=0;i<pts.length-1;i++){ pos.push(...pts[i],...pts[i+1]); }
    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    return new THREE.LineSegments(g, BLACK);
  }
  const rnd=(a,b)=>a+Math.random()*(b-a);

  // --- Ground circle (just a faint ring guideline) ---
  const groundRing = lineCircle(900, 256); groundRing.material.opacity=0.15; groundRing.material.transparent=true; scene.add(groundRing);

  // --- Track as two line circles ---
  const TRACK_RADIUS=85, GAUGE=0.6;
  const railIn = lineCircle(TRACK_RADIUS-GAUGE/2, 256);
  const railOut= lineCircle(TRACK_RADIUS+GAUGE/2, 256);
  scene.add(railIn, railOut);

  // --- “Trees” as stick cones + trunks (lines) ---
  function addTree(x,z,s){
    const g=new THREE.Group();
    const trunk=lineRect(0.1,2.2*s); trunk.position.set(0,1.1*s,0); g.add(trunk);
    const crown1=lineCircle(0.9*s,24); crown1.position.set(0,2.2*s,0); g.add(crown1);
    const crown2=lineCircle(0.6*s,18); crown2.position.set(0,3.1*s,0); g.add(crown2);
    g.position.set(x,0,z); scene.add(g);
  }
  for(let i=0;i<260;i++){ const r=rnd(110,280), th=rnd(0,Math.PI*2); if(Math.abs(r-TRACK_RADIUS)>10) addTree(Math.cos(th)*r,Math.sin(th)*r,rnd(.7,1.3)); }

  // --- Train cars as simple rectangles on the track ---
  const CAR_CT=20, CAR_SP=2.2;
  const train = new THREE.Group(); scene.add(train);
  const carGeom = lineRect(1.8,1.2);
  function makeCar(){ return carGeom.clone(); }
  const cars=[]; for(let i=0;i<CAR_CT;i++){ const c=makeCar(); cars.push(c); train.add(c); }

  const ANGLE_PER_M = 1 / TRACK_RADIUS;
  const ARC_SPACING = CAR_SP * ANGLE_PER_M;
  function placeCar(car, angle){
    car.position.set(Math.cos(angle)*TRACK_RADIUS,0,Math.sin(angle)*TRACK_RADIUS);
    car.rotation.y = Math.atan2(-Math.sin(angle), Math.cos(angle));
  }

  // --- Targets: line balloons / ducks / stars / buoys ---
  const TARGETS = new THREE.Group(); scene.add(TARGETS);
  function starLines(r){
    const spikes=5, outer=r*1.8, inner=r*0.8, g=new THREE.BufferGeometry(), pos=[];
    let rot=-Math.PI/2, step=Math.PI/spikes, last=null;
    for(let i=0;i<spikes*2;i++){
      const rad = (i%2===0)?outer:inner;
      const x=Math.cos(rot)*rad, y=0, z=Math.sin(rot)*rad;
      if(last){ pos.push(last.x,last.y,last.z, x,y,z); }
      last=new THREE.Vector3(x,y,z);
      rot+=step;
    }
    // close shape
    const firstX=Math.cos(-Math.PI/2)*outer, firstZ=Math.sin(-Math.PI/2)*outer;
    pos.push(last.x,0,last.z, firstX,0,firstZ);
    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    return new THREE.LineSegments(g, BLACK);
  }
  function balloon(r){
    const g=lineCircle(r,32);
    const string=lineRect(0.02, r*2.0); string.position.y = -r*1.1;
    const group=new THREE.Group(); group.add(g,string); return group;
  }
  function duck(r){
    const body=lineCircle(r*1.1,24);
    const head=lineCircle(r*0.7,18); head.position.set(0, r*0.9, r*0.4);
    const beak=lineRect(r*0.35, r*0.25); beak.position.copy(head.position).add(new THREE.Vector3(0,0,r*0.45));
    const g=new THREE.Group(); g.add(body,head,beak); return g;
  }
  function buoy(r){
    const base=lineCircle(r*0.8,16);
    const mast=lineRect(0.05, r*3.0); mast.position.y=r*1.5;
    const g=new THREE.Group(); g.add(base,mast); return g;
  }
  const targetKinds=['balloon','duck','buoy','star'];
  function makeTarget(){
    const kind = targetKinds[Math.floor(Math.random()*targetKinds.length)];
    const r = kind==='balloon'?0.28: kind==='duck'?0.30 : kind==='buoy'?0.32 : 0.30;
    let mesh;
    if(kind==='balloon') mesh=balloon(r);
    else if(kind==='duck') mesh=duck(r);
    else if(kind==='buoy') mesh=buoy(r);
    else mesh=starLines(r);
    mesh.userData = { kind, radius:r, alive:true, baseY:0.6+Math.random()*1.6, animT:Math.random()*10, points: kind==='star'?80: kind==='duck'?75: kind==='buoy'?60:50 };
    return mesh;
  }
  function spawnTargets(){
    for(let i=0;i<60;i++){
      const t = makeTarget();
      const ang = Math.random()*Math.PI*2;
      const rad = TRACK_RADIUS + (Math.random()<.5?-10:16) + Math.random()*10;
      t.position.set(Math.cos(ang)*rad, t.userData.baseY, Math.sin(ang)*rad);
      TARGETS.add(t);
    }
  }
  spawnTargets();

  // --- Input: yaw/pitch + shooting ---
  let yawDeg=0, pitchDeg=0, eyeY=0.9, targetEye=0.9;
  const PITCH_MIN=-80, PITCH_MAX=80;
  const scoreEl=document.getElementById('score'); let score=0;

  // drag to look
  (function(){
    const el=renderer.domElement; let drag=false,lx=0,ly=0; const s=0.18;
    const P=e=>e.touches?{x:e.touches[0].clientX,y:e.touches[0].clientY}:{x:e.clientX,y:e.clientY};
    el.addEventListener('pointerdown',e=>{drag=true; const p=P(e); lx=p.x; ly=p.y; el.setPointerCapture?.(e.pointerId||0); container.focus();});
    el.addEventListener('pointermove',e=>{ if(!drag) return; const p=P(e); const dx=p.x-lx, dy=p.y-ly; lx=p.x; ly=p.y; yawDeg+=dx*s; pitchDeg=Math.max(PITCH_MIN,Math.min(PITCH_MAX,pitchDeg-dy*s)); });
    const up=()=>{drag=false}; el.addEventListener('pointerup',up); el.addEventListener('pointerleave',up);
  })();
  // arrows + space
  window.addEventListener('keydown',e=>{
    const step=4;
    if(e.key==='ArrowLeft')  yawDeg-=step;
    if(e.key==='ArrowRight') yawDeg+=step;
    if(e.key==='ArrowUp')    pitchDeg=Math.min(PITCH_MAX, pitchDeg+step);
    if(e.key==='ArrowDown')  pitchDeg=Math.max(PITCH_MIN, pitchDeg-step);
    if(e.code==='Space'){ e.preventDefault(); shoot(); }
  });
  container.addEventListener('click', ()=>shoot());

  // --- Projectile + bursts (all line-based) ---
  const PROJECTILES=new THREE.Group(); scene.add(PROJECTILES);
  const PARTICLES=new THREE.Group(); scene.add(PARTICLES);

  function makeProjectile(){
    // a short line segment pointing forward
    const g=new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0, 0,0,-0.6],3));
    const line=new THREE.Line(g, BLACK);
    line.userData={ vel:new THREE.Vector3(), ttl:1.2, trailT:0 };
    return line;
  }
  function smokePuff(pos){
    // little expanding ring
    const ring=lineCircle(0.08,16);
    ring.position.copy(pos); ring.userData={ttl:0.35, grow:1.4, fade:1};
    PARTICLES.add(ring);
  }
  function popBurst(pos){
    // expanding ring + falling line sticks
    const ring=lineCircle(0.2,24); ring.position.copy(pos); ring.userData={ttl:0.5,grow:1.4,fade:1}; PARTICLES.add(ring);
    for(let i=0;i<14;i++){
      const stick=lineRect(0.02,0.12);
      stick.position.copy(pos);
      stick.userData={ vel:new THREE.Vector3((Math.random()-0.5)*1.3, Math.random()*1.6, (Math.random()-0.5)*1.3), ttl:0.8+Math.random()*0.6, rot:new THREE.Vector3(Math.random(),Math.random(),Math.random()) };
      PARTICLES.add(stick);
    }
  }

  function shoot(){
    // fire from camera forward
    const dir=new THREE.Vector3(); camera.getWorldDirection(dir).normalize();
    const start=camera.position.clone().addScaledVector(dir, 0.15);
    const p=makeProjectile(); p.position.copy(start); p.userData.vel.copy(dir).multiplyScalar(40);
    PROJECTILES.add(p); smokePuff(start);
  }

  function hitTarget(target, where){
    if(!target.userData.alive) return; target.userData.alive=false;
    score += target.userData.points || 50; scoreEl.textContent=String(score);
    popBurst(where); TARGETS.remove(target);
  }

  // --- Animate ---
  let theta=0; const clock=new THREE.Clock();
  function animate(){
    const dt=clock.getDelta();

    // train moves (constant slow pace, line version keeps it simple)
    const mph=10; // fixed speed for simplicity
    const mps=(mph*1609.344)/3600, angVel=mps/TRACK_RADIUS; theta += angVel*dt;
    for(let i=0;i<CAR_CT;i++){ placeCar(cars[i], theta - i*ARC_SPACING); }

    // camera ride 10 cars back + look
    const rideAng = theta - (10*ARC_SPACING);
    const pos = new THREE.Vector3(Math.cos(rideAng)*TRACK_RADIUS, eyeY, Math.sin(rideAng)*TRACK_RADIUS);
    const forward = new THREE.Vector3(-Math.sin(rideAng), 0, Math.cos(rideAng)).normalize();
    const up = new THREE.Vector3(0,1,0);
    const baseQ = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), forward);
    const yawQ  = new THREE.Quaternion().setFromAxisAngle(up, THREE.MathUtils.degToRad(yawDeg));
    const right = new THREE.Vector3().copy(forward).cross(up).normalize();
    const pitchQ= new THREE.Quaternion().setFromAxisAngle(right, THREE.MathUtils.degToRad(pitchDeg));
    camera.position.copy(pos); camera.quaternion.multiplyQuaternions(baseQ, yawQ).multiply(pitchQ);

    // idle target motion
    TARGETS.children.forEach(t=>{
      if(!t.userData.alive) return;
      t.userData.animT += dt;
      if(t.userData.kind==='balloon'){ t.position.y = t.userData.baseY + Math.sin(t.userData.animT*1.6)*0.12; }
      else if(t.userData.kind==='duck'){ t.position.x += Math.sin(t.userData.animT*0.8)*0.012; t.position.z += Math.cos(t.userData.animT*0.8)*0.012; }
      else if(t.userData.kind==='buoy'){ t.position.y = t.userData.baseY + Math.sin(t.userData.animT*1.2)*0.05; }
      else if(t.userData.kind==='star'){ t.rotation.y += 0.6*dt; }
    });

    // projectiles + simple collision (sphere radius)
    for(let i=PROJECTILES.children.length-1;i>=0;i--){
      const pr=PROJECTILES.children[i];
      pr.position.addScaledVector(pr.userData.vel, dt);
      pr.userData.ttl -= dt;
      pr.userData.trailT += dt;
      if(pr.userData.trailT>0.03){ pr.userData.trailT=0; smokePuff(pr.position.clone()); }

      let hit=false, tgt=null, where=null;
      for(let j=0;j<TARGETS.children.length;j++){
        const t=TARGETS.children[j]; if(!t.userData.alive) continue;
        const r=(t.userData.radius||0.3)+0.08;
        const wp=t.getWorldPosition(new THREE.Vector3());
        if(pr.position.distanceTo(wp) < r){ hit=true; tgt=t; where=pr.position.clone(); break; }
      }
      if(hit){ PROJECTILES.remove(pr); pr.geometry.dispose(); if(tgt) hitTarget(tgt, where); continue; }
      if(pr.userData.ttl<=0){ PROJECTILES.remove(pr); pr.geometry.dispose(); }
    }

    // particles (rings/sticks)
    for(let i=PARTICLES.children.length-1;i>=0;i--){
      const c=PARTICLES.children[i];
      if(c.geometry && c.userData && c.userData.grow){ // a ring
        c.userData.ttl -= dt; c.scale.multiplyScalar(c.userData.grow); c.userData.fade *= 0.9;
        c.material.opacity = c.userData.fade; c.material.transparent = true;
        if(c.userData.ttl<=0 || c.material.opacity<0.05){ PARTICLES.remove(c); c.geometry.dispose(); }
      }else if(c.geometry && c.userData && c.userData.vel){ // a stick
        c.userData.ttl -= dt; c.userData.vel.y -= 2.3*dt; c.position.addScaledVector(c.userData.vel, dt);
        c.rotation.x += c.userData.rot.x*dt*6; c.rotation.y += c.userData.rot.y*dt*6; c.rotation.z += c.userData.rot.z*dt*6;
        if(c.userData.ttl<=0){ PARTICLES.remove(c); c.geometry.dispose(); }
      }else{ // fallback
        PARTICLES.remove(c);
      }
    }

    renderer.render(scene,camera);
    requestAnimationFrame(animate);
  }
  animate();

  // focus so Space works
  setTimeout(()=>container.focus(), 50);
  setStatus('Line‑art mode. Click or Space to shoot; drag or use arrows to look.');
})();
</script>
</body>
</html>
