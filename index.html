<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Greenport Express — Miniature Railroad World</title>
<style>
  :root{--bg:#0b1220;--fg:#e5e7eb}
  html,body{height:100%;margin:0}
  body{font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0b1220;color:#e5e7eb}
  .wrap{position:fixed;inset:0;background:var(--bg);color:var(--fg)}
  .head{position:absolute;top:0;left:0;right:0;display:flex;align-items:center;justify-content:center;gap:12px;
        background:#fff;color:#0b1220;padding:10px 14px;box-shadow:0 10px 30px rgba(2,6,23,.12);z-index:3}
  .head h1{margin:0;font-size:18px}
  .badge{font-size:12px;color:#fff;background:linear-gradient(135deg,#0ea5e9,#22d3ee);padding:4px 8px;border-radius:999px}
  .headtoggle{position:absolute;left:14px}
  .scene{position:absolute;inset:44px 0 0 0}
  .hud{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);display:flex;align-items:center;gap:12px;
       padding:10px 12px;border-radius:14px;background:rgba(255,255,255,.95);backdrop-filter:blur(8px);
       box-shadow:0 10px 30px rgba(2,6,23,.15);z-index:3;color:#0b1220;flex-wrap:wrap}
  .ctl{display:grid;gap:6px;font-size:12px;color:#64748b}
  .sp{width:1px;align-self:stretch;background:rgba(100,116,139,.3)}
  .btn{appearance:none;border:0;background:#0ea5e9;color:#fff;padding:9px 12px;border-radius:12px;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(100,116,139,.4);color:#0b1220}
  .range{-webkit-appearance:none;appearance:none;width:220px;height:6px;border-radius:999px;background:rgba(100,116,139,.45)}
  .range::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:#0ea5e9;border:2px solid rgba(255,255,255,.9)}
  .hidden{display:none!important}
  #status{position:absolute;top:52px;left:12px;z-index:4;font-size:12px;color:#0369a1}

  /* Right-bottom look pad (left/right) */
  .pad{position:absolute;right:14px;bottom:14px;z-index:3;display:flex;gap:8px}
  .pad button{appearance:none;border:0;border-radius:10px;background:rgba(255,255,255,.95);
              box-shadow:0 6px 18px rgba(2,6,23,.15);color:#0b1220;font-weight:700;cursor:pointer;
              width:56px;height:56px}

  /* Mission + score ribbon (top-right) */
  .ribbon{position:absolute;top:52px;right:12px;z-index:4;background:rgba(255,255,255,.95);color:#0b1220;
          border-radius:12px;padding:10px 12px;box-shadow:0 10px 30px rgba(2,6,23,.15);min-width:220px}
  .ribbon .row{display:flex;align-items:center;justify-content:space-between;margin:2px 0}
  .tag{padding:2px 8px;border-radius:999px;background:#e2e8f0;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="head">
    <div class="headtoggle"><button id="toggleHeadline" class="ghost btn">Headline: On</button></div>
    <h1 id="headline">Greenport Express</h1>
    <span class="badge">Kids’ Miniature Railroad — Explore Greenport!</span>
  </div>

  <div id="status">Loading…</div>
  <div class="scene" id="scene"></div>

  <!-- Score / Mission -->
  <div class="ribbon">
    <div class="row"><strong>Score:</strong> <span id="score">0</span></div>
    <div class="row"><span class="tag">Shells</span><span id="shells">0 / 12</span></div>
    <div class="row"><span class="tag">Passengers</span><span id="pax">0</span></div>
    <hr style="border:none;border-top:1px solid #e5e7eb;margin:8px 0">
    <div style="font-size:12px;color:#334155">Daily Mission</div>
    <div id="mission" style="font-size:13px">Pick up 6 passengers at the Carnival.</div>
    <button id="reroll" class="btn ghost" style="margin-top:6px;padding:6px 10px">New Mission</button>
  </div>

  <!-- Main HUD -->
  <div class="hud">
    <div class="ctl">
      <label for="speed">Speed</label>
      <input id="speed" class="range" type="range" min="0" max="35" value="12" />
    </div>
    <div style="font-size:12px;color:#64748b"><strong id="mph">12</strong> mph</div>
    <div class="sp"></div>
    <button id="whistle" class="btn">Whistle</button>
    <button id="bell" class="btn ghost">Bell</button>
    <div class="sp"></div>
    <button id="dark" class="btn">Night</button>
    <button id="tall" class="btn ghost" title="See over the cars">Tall: Off</button>
    <button id="center" class="btn ghost">Center View</button>
    <button id="photo" class="btn ghost">Photo</button>
  </div>

  <!-- On-screen look controls -->
  <div class="pad" aria-label="look controls">
    <button id="padLeft">←</button>
    <button id="padRight">→</button>
  </div>
</div>

<!-- Local Three.js (no CDNs) -->
<script src="./three.min.js"></script>
<script>
(function(){
  const statusEl = document.getElementById('status');
  const setStatus = m => (statusEl.textContent = m);

  if (!window.THREE){ setStatus('ERROR: three.min.js not found next to index.html'); return; }
  const THREE = window.THREE;

  // ————— Basic setup —————
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  // Ambient env (PMREM from a quick canvas grad)
  const pmrem = new THREE.PMREMGenerator(renderer);
  const envCanvas = document.createElement('canvas');
  envCanvas.width = envCanvas.height = 256;
  const eg = envCanvas.getContext('2d');
  const grd = eg.createLinearGradient(0,0,0,256);
  grd.addColorStop(0,'#cfe8ff'); grd.addColorStop(1,'#9fc3ff');
  eg.fillStyle = grd; eg.fillRect(0,0,256,256);
  const envTex = new THREE.CanvasTexture(envCanvas);
  envTex.colorSpace = THREE.SRGBColorSpace;
  scene.environment = pmrem.fromEquirectangular(envTex).texture;
  envTex.dispose();

  // Camera rigs
  const camera = new THREE.PerspectiveCamera(72, 1, 0.05, 2500);
  const camYaw = new THREE.Object3D();
  const camPitch = new THREE.Object3D(); // keep pitch flat (no up/down look)
  camYaw.add(camPitch); camPitch.add(camera);
  scene.add(camYaw);

  // Lights + day/night
  const hemi = new THREE.HemisphereLight(0xffffff, 0x2a3b2a, 0.6); scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 2.1);
  sun.position.set(90,140,60);
  sun.castShadow=true; sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.near=1; sun.shadow.camera.far=600;
  sun.shadow.camera.left=-160; sun.shadow.camera.right=160;
  sun.shadow.camera.top=160; sun.shadow.camera.bottom=-160;
  scene.add(sun);

  const nightGroup = new THREE.Group(); // neon, ferris bulbs, lighthouse beam live here
  nightGroup.visible = false; scene.add(nightGroup);

  // Ground disk
  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(900, 128),
    new THREE.MeshStandardMaterial({ color:0x98cfa7, roughness:0.95 })
  );
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  // ===== Track, ties, ballast =====
  const TRACK_RADIUS = 85, GAUGE=0.6;
  function CirclePath(r){ this.radius=r; }
  CirclePath.prototype = Object.create(THREE.Curve.prototype);
  CirclePath.prototype.getPoint=function(t){ const a=t*Math.PI*2; return new THREE.Vector3(Math.cos(a)*this.radius,0,Math.sin(a)*this.radius); };

  const railMat = new THREE.MeshStandardMaterial({ color:0x7e8790, metalness:1.0, roughness:0.25, envMapIntensity:1.2 });
  const RAIL_R = 0.055;
  const innerRail = new THREE.Mesh(new THREE.TubeGeometry(new CirclePath(TRACK_RADIUS-GAUGE/2), 960, RAIL_R, 16, true), railMat);
  const outerRail = new THREE.Mesh(new THREE.TubeGeometry(new CirclePath(TRACK_RADIUS+GAUGE/2), 960, RAIL_R, 16, true), railMat);
  innerRail.castShadow = outerRail.castShadow = true; innerRail.receiveShadow = outerRail.receiveShadow = true; scene.add(innerRail, outerRail);

  const ballast = new THREE.Mesh(
    new THREE.RingGeometry(TRACK_RADIUS-GAUGE/2-1.2, TRACK_RADIUS+GAUGE/2+1.2, 200),
    new THREE.MeshStandardMaterial({ color:0x8e99a3, roughness:1 })
  );
  ballast.geometry.rotateX(-Math.PI/2); ballast.receiveShadow = true; scene.add(ballast);

  // Ties
  const TIE_CT = 760, TIE_W = GAUGE + 0.6, TIE_H = 0.14, TIE_D = 0.32;
  const tieGeo = new THREE.BoxGeometry(TIE_W, TIE_H, TIE_D);
  const tieMat = new THREE.MeshStandardMaterial({ color:0x7b5e3b, roughness:.95 });
  const ties = new THREE.InstancedMesh(tieGeo, tieMat, TIE_CT);
  const m4 = new THREE.Matrix4(), q = new THREE.Quaternion();
  for(let i=0;i<TIE_CT;i++){
    const t = i/TIE_CT, ang = t*Math.PI*2, x = Math.cos(ang)*TRACK_RADIUS, z = Math.sin(ang)*TRACK_RADIUS;
    q.setFromEuler(new THREE.Euler(0, ang, 0));
    m4.compose(new THREE.Vector3(x, -TIE_H/2 + 0.01, z), q, new THREE.Vector3(1,1,1));
    ties.setMatrixAt(i, m4);
  }
  ties.castShadow = ties.receiveShadow = true; scene.add(ties);

  // ===== Trees (fast, layered) =====
  const trunkGeo = new THREE.CylinderGeometry(0.35,0.45,2.8, 10);
  const trunkMat = new THREE.MeshStandardMaterial({ color:0x6b4f2c, roughness:.95 });
  const foliageMat = new THREE.MeshStandardMaterial({ color:0x2f7a4a, roughness:.9, metalness:0, envMapIntensity:0.2 });
  const rand=(a,b)=>a+Math.random()*(b-a);
  function addTree(x,z,s){
    const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.scale.set(s,s,s);
    trunk.position.set(x,1.4*s,z); trunk.castShadow=trunk.receiveShadow=true; scene.add(trunk);
    const cones=[ [1.7,3.0, 3.0], [1.4,2.6, 4.4], [1.1,2.2, 5.7] ];
    cones.forEach(([r,h,y])=>{
      const c=new THREE.Mesh(new THREE.ConeGeometry(r*s,h*s, 12), foliageMat);
      c.position.set(x,y*s,z); c.castShadow=true; scene.add(c);
    });
  }
  for(let i=0;i<900;i++){ const r=rand(95,860), th=rand(0,Math.PI*2); addTree(Math.cos(th)*r, Math.sin(th)*r, rand(.6,1.25)); }
  // inner band away from rails
  for(let i=0;i<280;i++){ const r=rand(110,280), th=rand(0,Math.PI*2); if(Math.abs(r-TRACK_RADIUS)>12) addTree(Math.cos(th)*r, Math.sin(th)*r, rand(.6,1.0)); }

  // ===== Attractions =====
  const POI = []; // {name, ang, group}
  function addPOI(name, ang, group){ POI.push({name,ang,group}); scene.add(group); }

  // A) Carnival with Ferris Wheel
  const carnival = new THREE.Group();
  const wheel = new THREE.Group();
  const wheelR = 7;
  const rim = new THREE.Mesh(new THREE.TorusGeometry(wheelR, 0.18, 8, 48), new THREE.MeshStandardMaterial({color:0xffffff, metalness:.2, roughness:.4, emissive:0x111111}));
  const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,2,16), new THREE.MeshStandardMaterial({color:0xaaaaaa, metalness:.6, roughness:.4}));
  hub.rotation.z = Math.PI/2; wheel.add(rim, hub);
  // gondolas (boxes)
  for(let i=0;i<12;i++){
    const a = i/12 * Math.PI*2;
    const box = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.7,0.8), new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL(i/12,0.6,0.55)}));
    box.position.set(Math.cos(a)*wheelR, Math.sin(a)*wheelR, 0);
    wheel.add(box);
    // bulbs for night
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.18,10,10), new THREE.MeshStandardMaterial({emissive:new THREE.Color().setHSL(i/12,1,0.6), color:0x000000, emissiveIntensity:2}));
    bulb.position.set(Math.cos(a)*wheelR*1.02, Math.sin(a)*wheelR*1.02, 0.2);
    nightGroup.add(bulb); bulb.position.add(carnival.position);
  }
  carnival.add(wheel);
  const booth = new THREE.Mesh(new THREE.BoxGeometry(4,2.4,2.2), new THREE.MeshStandardMaterial({color:0xffb4c7, roughness:.9}));
  booth.position.set(-6,-0.3,-4); carnival.add(booth);
  addPOI('Carnival', Math.PI*0.05, carnival);

  // B) Skate Park (ramps + a moving skater)
  const skate = new THREE.Group();
  const rampMat = new THREE.MeshStandardMaterial({color:0xbfc9d1, roughness:.8});
  const ramp1 = new THREE.Mesh(new THREE.CylinderGeometry(4,4,6,24,1,true,0,Math.PI/2), rampMat);
  ramp1.rotation.z = Math.PI/2; ramp1.position.set(0,0,3);
  const ramp2 = ramp1.clone(); ramp2.position.set(0,0,-3); ramp2.rotation.y = Math.PI;
  skate.add(ramp1,ramp2);
  const skater = new THREE.Mesh(new THREE.BoxGeometry(0.8,1.2,0.4), new THREE.MeshStandardMaterial({color:0x1e293b}));
  skater.position.y = 0.8; skate.add(skater);
  addPOI('Skate Park', Math.PI*0.38, skate);

  // C) Lighthouse with sweeping beam
  const lightHouse = new THREE.Group();
  const tower = new THREE.Mesh(new THREE.CylinderGeometry(1.5,2.2,12,16), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.9}));
  const cap = new THREE.Mesh(new THREE.ConeGeometry(1.8,2,16), new THREE.MeshStandardMaterial({color:0xcc0000, roughness:.6}));
  cap.position.y = 7; tower.position.y = 5;
  lightHouse.add(tower,cap);
  const beam = new THREE.SpotLight(0xffeeaa, 12, 120, Math.PI/16, 0.35, 1.0);
  beam.position.set(0, 10.2, 0); beam.target.position.set(10,9,0);
  nightGroup.add(beam, beam.target);
  addPOI('Lighthouse', Math.PI*0.62, lightHouse);

  // D) Harbor with boats
  const harbor = new THREE.Group();
  const water = new THREE.Mesh(new THREE.CircleGeometry(55, 48), new THREE.MeshStandardMaterial({color:0x69b3ff, metalness:.1, roughness:.4}));
  water.rotation.x = -Math.PI/2; harbor.add(water);
  function makeBoat(col){
    const g = new THREE.Group();
    const hull = new THREE.Mesh(new THREE.CapsuleGeometry(2.4, 4.0, 4, 12), new THREE.MeshStandardMaterial({color:col, roughness:.7, metalness:.2}));
    hull.rotation.z = Math.PI/2; g.add(hull);
    const cab = new THREE.Mesh(new THREE.BoxGeometry(1.6,1,1.2), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.9}));
    cab.position.set(0.6,0.9,0); g.add(cab);
    return g;
  }
  const boat1 = makeBoat(0x0ea5e9), boat2 = makeBoat(0x22c55e), boat3 = makeBoat(0xf97316);
  boat1.position.set(-10,0,10); boat2.position.set(8,0,-6); boat3.position.set(12,0,14);
  harbor.add(boat1,boat2,boat3);
  // seagulls (little cones that circle)
  const gulls = new THREE.Group();
  for(let i=0;i<10;i++){
    const g = new THREE.Mesh(new THREE.ConeGeometry(0.25,0.5,8), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.8}));
    g.rotation.x = Math.PI; gulls.add(g);
  }
  harbor.add(gulls);
  addPOI('Harbor', Math.PI*0.80, harbor);

  // Place POIs around the loop
  function placeAround(group, ang, radius){
    group.position.set(Math.cos(ang)*radius, 0, Math.sin(ang)*radius);
    group.lookAt(0,0,0);
  }
  POI.forEach(p=>placeAround(p.group, p.ang, TRACK_RADIUS+18));

  // ===== Train (coal cars + kids with faces) =====
  const CAR_CT = 24, CAR_SP = 2.2;
  const carMat = new THREE.MeshStandardMaterial({ color:0xbfc5cc, metalness:.85, roughness:.35, envMapIntensity:1.5 });
  function makeCoalCar(){
    const g = new THREE.Group();
    const shell = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 1.2), carMat); shell.castShadow = shell.receiveShadow = true; g.add(shell);
    const inner = new THREE.Mesh(new THREE.BoxGeometry(1.73, 0.42, 1.12), new THREE.MeshStandardMaterial({ color:0xaeb4bb, metalness:.2, roughness:.9 }));
    inner.position.y = 0.05; inner.receiveShadow=true; g.add(inner);
    const wheelMat = new THREE.MeshStandardMaterial({ color:0x2d2f33, metalness:.5, roughness:.5 });
    const wheel = (x,z)=>{ const w=new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.22,0.28,16), wheelMat); w.rotation.z=Math.PI/2; w.position.set(x,-0.42,z); w.castShadow=true; g.add(w); };
    wheel(-0.6, 0.55); wheel(-0.6,-0.55); wheel(0.6,0.55); wheel(0.6,-0.55);
    const coupler = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.1,0.1), new THREE.MeshStandardMaterial({color:0x444, roughness:.7}));
    coupler.position.x = 0.9 + 0.1; g.add(coupler);
    return g;
  }
  const geoHead = new THREE.SphereGeometry(0.18,16,12), matSkin=new THREE.MeshStandardMaterial({color:0xffd6b0, roughness:.6});
  const geoEye = new THREE.SphereGeometry(0.03,10,8),  matEye=new THREE.MeshStandardMaterial({color:0x111111});
  const geoMouth = new THREE.CylinderGeometry(0.055, 0.055, 0.02, 16), matMouth=new THREE.MeshStandardMaterial({color:0x843434, roughness:.6});
  const geoHairTop = new THREE.SphereGeometry(0.20,16,12), geoHairBand=new THREE.CylinderGeometry(0.205,0.205,0.06,16);

  function makeKid(){
    const g = new THREE.Group();
    const head = new THREE.Mesh(geoHead, matSkin); head.position.y = 0.18; g.add(head);
    const eyeL = new THREE.Mesh(geoEye, matEye), eyeR = eyeL.clone();
    eyeL.position.set(-0.055,0.21,0.16); eyeR.position.set(0.055,0.21,0.16); g.add(eyeL,eyeR);
    const mouth = new THREE.Mesh(geoMouth, matMouth); mouth.rotation.x=Math.PI/2; mouth.scale.set(1,0.65,1); mouth.position.set(0,0.13,0.17); g.add(mouth);
    const hairCol = new THREE.Color().setHSL(Math.random()*0.12+0.05, 0.5, 0.25);
    const matHair = new THREE.MeshStandardMaterial({color:hairCol, roughness:.8, metalness:0.05});
    const cap = new THREE.Mesh(geoHairTop, matHair); cap.scale.y=0.6; cap.position.y=0.30;
    const band = new THREE.Mesh(geoHairBand, matHair); band.position.y=0.25;
    g.add(cap,band);
    return g;
  }

  const train = new THREE.Group(), cars=[];
  for(let i=0;i<CAR_CT;i++){
    const car = makeCoalCar();
    const k1 = makeKid(); k1.position.set(-0.3,0.45, 0.22);
    const k2 = makeKid(); k2.position.set( 0.25,0.45,-0.18);
    car.add(k1,k2);
    cars.push(car); train.add(car);
  }
  scene.add(train);

  // Helpers for placement
  const ANGLE_PER_M = 1 / TRACK_RADIUS;
  const ARC_SPACING = CAR_SP * ANGLE_PER_M;
  function placeCar(car, angle){
    const x = Math.cos(angle) * TRACK_RADIUS;
    const z = Math.sin(angle) * TRACK_RADIUS;
    const tx = -Math.sin(angle), tz = Math.cos(angle);
    car.position.set(x, 0, z);
    car.rotation.y = Math.atan2(tx, tz);
  }

  // ===== Collectibles: shells =====
  const shellsGroup = new THREE.Group(); scene.add(shellsGroup);
  const shellMat = new THREE.MeshStandardMaterial({color:0xfff3bf, metalness:.2, roughness:.5, emissive:0x665500, emissiveIntensity:0.08});
  const shellGeo = new THREE.SphereGeometry(0.12, 12, 10);
  const shellAngles = []; const SHELL_CT = 12;
  for(let i=0;i<SHELL_CT;i++){
    const t = Math.random(); const a = t*Math.PI*2;
    const r = TRACK_RADIUS + (Math.random()<0.5? -1.2 : 1.2);
    const m = new THREE.Mesh(shellGeo, shellMat);
    m.position.set(Math.cos(a)*r, 0.12, Math.sin(a)*r);
    m.userData.ang = a; shellsGroup.add(m); shellAngles.push(a);
  }

  // ===== Passenger stops (bonus) =====
  const stops = [
    { name: 'Carnival Station', ang: POI.find(p=>p.name==='Carnival').ang, group: new THREE.Group() },
    { name: 'Harbor Dock', ang: POI.find(p=>p.name==='Harbor').ang + 0.06, group: new THREE.Group() },
  ];
  stops.forEach(s=>{
    const p = new THREE.Mesh(new THREE.BoxGeometry(3.5,0.2,1.2), new THREE.MeshStandardMaterial({color:0x333333, roughness:.9}));
    s.group.add(p);
    placeAround(s.group, s.ang, TRACK_RADIUS-2.2);
    scene.add(s.group);
  });

  // ===== UI state =====
  const $ = id=>document.getElementById(id);
  let mph = parseFloat($("speed").value);
  $("mph").textContent = String(mph);
  $("speed").addEventListener("input", ()=>{ mph=parseFloat($("speed").value); $("mph").textContent=String(mph); });

  let yawDeg = 0;
  let targetEye = 0.62, isTall=false;
  const SEATED = 0.62, TALL = 1.05;

  let score=0, shells=0, pax=0;
  const incScore=n=>{ score+=n; $("score").textContent=String(score); };
  const setShells=()=>{ $("shells").textContent=`${shells} / ${SHELL_CT}`; };
  const setPax=()=>{ $("pax").textContent=String(pax); };

  // Daily mission (simple rotation)
  const missions = [
    'Pick up 6 passengers at the Carnival.',
    'Collect 5 shells near the Harbor.',
    'Finish a lap under 2:30 minutes.',
    'Wave whistle at the Lighthouse and Skate Park.'
  ];
  function reroll(){ $("mission").textContent = missions[Math.floor(Math.random()*missions.length)]; }
  reroll(); $("reroll").addEventListener("click", reroll);

  // Look controls (no up/down)
  window.addEventListener("keydown",(e)=>{
    if(e.key==='ArrowLeft') yawDeg-=4;
    if(e.key==='ArrowRight') yawDeg+=4;
  });
  function hold(btn, fn){ let t=null;
    const start=ev=>{ev.preventDefault(); if(t) return; fn(); t=setInterval(fn,80)};
    const stop =()=>{clearInterval(t);t=null};
    btn.addEventListener('pointerdown',start); btn.addEventListener('pointerup',stop);
    btn.addEventListener('pointerleave',stop); btn.addEventListener('pointercancel',stop);
  }
  hold($("padLeft"), ()=>{yawDeg-=4}); hold($("padRight"), ()=>{yawDeg+=4});

  // Tall toggle
  $("tall").addEventListener("click", ()=>{
    isTall=!isTall; targetEye=isTall?TALL:SEATED;
    $("tall").textContent=`Tall: ${isTall?'On':'Off'}`;
    $("tall").classList.toggle('ghost', !isTall);
  });

  // Dark / Night
  let isNight=false;
  function setNight(on){
    isNight=on; nightGroup.visible=on;
    if(on){ renderer.setClearColor(0x06101f,1); hemi.intensity=.25; sun.intensity=1.1; }
    else { renderer.setClearColor(0xcfe8ff,1); hemi.intensity=.6; sun.intensity=2.1; }
    $("dark").textContent = on? 'Day' : 'Night';
  }
  setNight(false);
  $("dark").addEventListener("click", ()=>setNight(!isNight));

  // Headline toggle
  let headlineOn = true;
  $("toggleHeadline").addEventListener("click", ()=>{
    headlineOn = !headlineOn;
    $("headline").classList.toggle("hidden", !headlineOn);
    $("toggleHeadline").textContent = `Headline: ${headlineOn?'On':'Off'}`;
  });

  // Audio (whistle/bell)
  const audio = new (window.AudioContext||window.webkitAudioContext)();
  const whistle = ()=>{
    const o=audio.createOscillator(), g=audio.createGain(); g.gain.value=0.001; o.type='sine';
    o.frequency.setValueAtTime(720,audio.currentTime);
    o.frequency.exponentialRampToValueAtTime(1100,audio.currentTime+0.35);
    o.frequency.exponentialRampToValueAtTime(680,audio.currentTime+0.9);
    g.gain.exponentialRampToValueAtTime(0.5,audio.currentTime+0.04);
    g.gain.exponentialRampToValueAtTime(0.32,audio.currentTime+0.4);
    g.gain.exponentialRampToValueAtTime(0.001,audio.currentTime+1.0);
    o.connect(g).connect(audio.destination); o.start(); o.stop(audio.currentTime+1.05);
  };
  const bell = ()=>{
    const o1=audio.createOscillator(), o2=audio.createOscillator(), g=audio.createGain();
    o1.type=o2.type='sine'; o1.frequency.value=660; o2.frequency.value=990; g.gain.value=0.001;
    g.gain.exponentialRampToValueAtTime(0.35,audio.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.001,audio.currentTime+0.6);
    o1.connect(g); o2.connect(g); g.connect(audio.destination);
    o1.start(); o2.start(); o1.stop(audio.currentTime+0.65); o2.stop(audio.currentTime+0.65);
  };
  $("whistle").addEventListener("click", ()=>{ if(audio.state==='suspended') audio.resume(); whistle(); });
  $("bell").addEventListener("click", ()=>{ if(audio.state==='suspended') audio.resume(); bell(); });

  // Photo mode: download the canvas
  $("photo").addEventListener("click", ()=>{
    const a=document.createElement('a');
    a.download='greenport-express.png'; a.href=renderer.domElement.toDataURL('image/png'); a.click();
  });

  // Resize
  function fit(){
    const r = container.getBoundingClientRect();
    const w = Math.max(1,r.width), h = Math.max(1,r.height);
    camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false);
  }
  new ResizeObserver(fit).observe(container); fit();

  // ===== Animation / game loop =====
  const clock = new THREE.Clock(); let theta=0, lapTime=0;

  function animate(){
    const dt = clock.getDelta(); lapTime += dt;
    const mps = (mph * 1609.344) / 3600;
    const angVel = mps / TRACK_RADIUS;
    theta += angVel * dt;

    // Move / place cars
    for(let i=0;i<CAR_CT;i++){
      const ang = theta - i * ARC_SPACING;
      placeCar(cars[i], ang);
    }

    // Camera (ride ~10 cars back) with gentle eye smoothing + yaw
    const rideAng = theta - (10 * ARC_SPACING);
    const cx = Math.cos(rideAng) * TRACK_RADIUS, cz = Math.sin(rideAng) * TRACK_RADIUS;
    const tx = -Math.sin(rideAng), tz = Math.cos(rideAng);
    const tangentY = Math.atan2(tx, tz);
    const curY = camYaw.position.y || SEATED;
    const newY = curY + (targetEye - curY) * 0.12;
    camYaw.position.set(cx, newY + Math.sin(clock.elapsedTime*2.5)*0.015, cz);
    camYaw.rotation.y = tangentY + THREE.MathUtils.degToRad(yawDeg);
    camPitch.rotation.x = 0;
    camera.position.set(0,0,0);

    // Attractions animate
    wheel.rotation.z += 0.35 * dt; // ferris
    skater.position.x = Math.sin(clock.elapsedTime*1.3) * 2.6;
    [boat1,boat2,boat3].forEach((b,i)=>{
      b.position.y = Math.sin(clock.elapsedTime*1.2 + i)*0.12;
      b.rotation.y += 0.15*dt;
    });
    gulls.children.forEach((g,i)=>{
      const a = clock.elapsedTime*0.7 + i*0.6; const r=10+ (i%3)*1.6;
      g.position.set(Math.cos(a)*r, 2.2 + Math.sin(a*2)*0.6, Math.sin(a)*r);
    });
    if(isNight){ beam.target.position.set(Math.cos(clock.elapsedTime*0.5)*40, 6, Math.sin(clock.elapsedTime*0.5)*40); }

    // Collectibles: auto-pick if close along the loop
    const trainPos = new THREE.Vector3(cx,0,cz);
    shellsGroup.children.forEach(m=>{
      if(m.visible && m.position.distanceTo(trainPos) < 1.2){
        m.visible=false; shells++; setShells(); incScore(50);
      }
    });

    // Passenger stops: within angle window = pickup
    stops.forEach(s=>{
      const d = Math.abs(Math.atan2(Math.sin(rideAng - s.ang), Math.cos(rideAng - s.ang)));
      if(d < 0.03 && mps>0.1){ pax+=1; setPax(); incScore(100); s.ang += 0.8 + Math.random()*0.6; placeAround(s.group, s.ang, TRACK_RADIUS-2.2); }
    });

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  setStatus('Explore, collect shells, pick up passengers — and check out the Carnival, Harbor, Skate Park, and Lighthouse!');
})();
</script>
</body>
</html>
