<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Greenport Express — Ride 10 Cars Back</title>
<style>
  :root{--bg:#0b1220;--fg:#e5e7eb}
  html,body{height:100%;margin:0}
  body{font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0b1220;color:#e5e7eb}
  .wrap{position:fixed;inset:0;background:var(--bg);color:var(--fg)}
  .head{position:absolute;top:0;left:0;right:0;display:flex;align-items:center;justify-content:center;gap:12px;
        background:#fff;color:#0b1220;padding:10px 14px;box-shadow:0 10px 30px rgba(2,6,23,.12);z-index:3}
  .head h1{margin:0;font-size:18px}
  .badge{font-size:12px;color:#fff;background:linear-gradient(135deg,#0ea5e9,#22d3ee);padding:4px 8px;border-radius:999px}
  .headtoggle{position:absolute;left:14px}
  .scene{position:absolute;inset:44px 0 0 0}
  .hud{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);display:flex;align-items:center;gap:12px;
       padding:10px 12px;border-radius:14px;background:rgba(255,255,255,.9);backdrop-filter:blur(8px);
       box-shadow:0 10px 30px rgba(2,6,23,.15);z-index:3;color:#0b1220}
  .ctl{display:grid;gap:6px;font-size:12px;color:#64748b}
  .sp{width:1px;align-self:stretch;background:rgba(100,116,139,.3)}
  .btn{appearance:none;border:0;background:#0ea5e9;color:#fff;padding:9px 12px;border-radius:12px;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(100,116,139,.4);color:#0b1220}
  .range{-webkit-appearance:none;appearance:none;width:220px;height:6px;border-radius:999px;background:rgba(100,116,139,.45)}
  .range::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:#0ea5e9;border:2px solid rgba(255,255,255,.9)}
  .hidden{display:none!important}
  .dark{--bg:#0b1220;--fg:#e5e7eb}
  #status{position:absolute;top:52px;left:12px;z-index:4;font-size:12px;color:#0369a1}

  /* Right-bottom look pad (only left/right active) */
  .pad{position:absolute;right:14px;bottom:14px;z-index:3;display:flex;gap:8px}
  .pad button{appearance:none;border:0;border-radius:10px;background:rgba(255,255,255,.95);
              box-shadow:0 6px 18px rgba(2,6,23,.15);color:#0b1220;font-weight:700;cursor:pointer;
              width:56px;height:56px}
</style>
</head>
<body>
<div class="wrap">
  <div class="head">
    <div class="headtoggle"><button id="toggleHeadline" class="ghost btn">Headline: On</button></div>
    <h1 id="headline">Greenport Express</h1>
    <span class="badge">Riding 10 Cars Back — Miniature Railroad</span>
  </div>
  <div id="status">Loading…</div>
  <div class="scene" id="scene"></div>

  <div class="hud">
    <div class="ctl">
      <label for="speed">Speed</label>
      <input id="speed" class="range" type="range" min="0" max="35" value="12" />
    </div>
    <div style="font-size:12px;color:#64748b"><strong id="mph">12</strong> mph</div>
    <div class="sp"></div>
    <button id="whistle" class="btn">Blow Whistle</button>
    <button id="bell" class="btn ghost">Bell</button>
    <div class="sp"></div>
    <button id="dark" class="btn">Dark Mode</button>
    <button id="tall" class="btn ghost" title="Toggle rider height">Tall: Off</button>
    <button id="center" class="btn ghost">Center View</button>
  </div>

  <!-- On-screen look controls (left/right only) -->
  <div class="pad" aria-label="look controls">
    <button id="padLeft">←</button>
    <button id="padRight">→</button>
  </div>
</div>

<!-- Local Three.js (no CDNs) -->
<script src="./three.min.js"></script>
<script>
(function(){
  const statusEl = document.getElementById('status');
  const log = m => (statusEl.textContent = m);
  if (!window.THREE){ log('ERROR: three.min.js not found next to index.html'); return; }
  const THREE = window.THREE;

  // Renderer / Scene / Camera
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  // Simple env for PBR reflections
  const pmrem = new THREE.PMREMGenerator(renderer);
  const envCanvas = document.createElement('canvas');
  envCanvas.width = envCanvas.height = 256;
  const eg = envCanvas.getContext('2d');
  const grd = eg.createLinearGradient(0,0,0,256);
  grd.addColorStop(0,'#cfe8ff'); grd.addColorStop(1,'#9fc3ff');
  eg.fillStyle = grd; eg.fillRect(0,0,256,256);
  const envTex = new THREE.CanvasTexture(envCanvas);
  envTex.colorSpace = THREE.SRGBColorSpace;
  scene.environment = pmrem.fromEquirectangular(envTex).texture;
  envTex.dispose();

  // Camera rigs
  const camera = new THREE.PerspectiveCamera(72, 1, 0.05, 2000);
  const camYaw = new THREE.Object3D();
  const camPitch = new THREE.Object3D(); // we keep this flat (no pitch look)
  camYaw.add(camPitch); camPitch.add(camera);
  scene.add(camYaw);

  // Lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x2a3b2a, 0.5); scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 2.0);
  sun.position.set(80,120,60);
  sun.castShadow=true; sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.near=1; sun.shadow.camera.far=400;
  sun.shadow.camera.left=-120; sun.shadow.camera.right=120;
  sun.shadow.camera.top=120; sun.shadow.camera.bottom=-120;
  scene.add(sun);

  // Ground
  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(520, 128),
    new THREE.MeshStandardMaterial({ color:0xa8d2b4, roughness:0.95 })
  );
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  // Track
  const TRACK_RADIUS = 60, GAUGE = 0.6;
  function CirclePath(r){ this.radius=r; }
  CirclePath.prototype = Object.create(THREE.Curve.prototype);
  CirclePath.prototype.getPoint=function(t){ const a=t*Math.PI*2; return new THREE.Vector3(Math.cos(a)*this.radius,0,Math.sin(a)*this.radius); };

  const railMat = new THREE.MeshStandardMaterial({ color:0x7e8790, metalness:1.0, roughness:0.25, envMapIntensity:1.2 });
  const RAIL_R = 0.05;
  const innerRail = new THREE.Mesh(new THREE.TubeGeometry(new CirclePath(TRACK_RADIUS-GAUGE/2), 640, RAIL_R, 16, true), railMat);
  const outerRail = new THREE.Mesh(new THREE.TubeGeometry(new CirclePath(TRACK_RADIUS+GAUGE/2), 640, RAIL_R, 16, true), railMat);
  innerRail.castShadow = outerRail.castShadow = true;
  innerRail.receiveShadow = outerRail.receiveShadow = true;
  scene.add(innerRail, outerRail);

  const ballast = new THREE.Mesh(
    new THREE.RingGeometry(TRACK_RADIUS-GAUGE/2-1.1, TRACK_RADIUS+GAUGE/2+1.1, 160),
    new THREE.MeshStandardMaterial({ color:0x8e99a3, roughness:1 })
  );
  ballast.geometry.rotateX(-Math.PI/2); ballast.receiveShadow = true; scene.add(ballast);

  // Ties
  const TIE_CT = 500, TIE_W = GAUGE + 0.5, TIE_H = 0.14, TIE_D = 0.28;
  const tieGeo = new THREE.BoxGeometry(TIE_W, TIE_H, TIE_D);
  const tieMat = new THREE.MeshStandardMaterial({ color:0x7b5e3b, roughness:.95 });
  const ties = new THREE.InstancedMesh(tieGeo, tieMat, TIE_CT);
  const m4 = new THREE.Matrix4(), q = new THREE.Quaternion();
  for(let i=0;i<TIE_CT;i++){
    const t = i/TIE_CT, ang = t*Math.PI*2, x = Math.cos(ang)*TRACK_RADIUS, z = Math.sin(ang)*TRACK_RADIUS;
    q.setFromEuler(new THREE.Euler(0, ang, 0));
    m4.compose(new THREE.Vector3(x, -TIE_H/2 + 0.01, z), q, new THREE.Vector3(1,1,1));
    ties.setMatrixAt(i, m4);
  }
  ties.castShadow = ties.receiveShadow = true; scene.add(ties);

  // Trees
  const trunkGeo = new THREE.CylinderGeometry(0.35,0.45,2.6, 10);
  const trunkMat = new THREE.MeshStandardMaterial({ color:0x6b4f2c, roughness:.95 });
  const foliageMat = new THREE.MeshStandardMaterial({ color:0x2f7a4a, roughness:.9, metalness:0, envMapIntensity:0.2 });
  const rand=(a,b)=>a+Math.random()*(b-a);
  function addTree(x,z,s){
    const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.scale.set(s,s,s);
    trunk.position.set(x,1.3*s,z); trunk.castShadow=trunk.receiveShadow=true; scene.add(trunk);
    const c1=new THREE.Mesh(new THREE.ConeGeometry(1.7*s,3.0*s, 12), foliageMat); c1.position.set(x,3.0*s,z); c1.castShadow=true;
    const c2=new THREE.Mesh(new THREE.ConeGeometry(1.4*s,2.6*s, 12), foliageMat); c2.position.set(x,4.4*s,z); c2.castShadow=true;
    const c3=new THREE.Mesh(new THREE.ConeGeometry(1.1*s,2.2*s, 12), foliageMat); c3.position.set(x,5.6*s,z); c3.castShadow=true;
    scene.add(c1,c2,c3);
  }
  for(let i=0;i<600;i++){ const r=rand(70,500), th=rand(0,Math.PI*2); addTree(Math.cos(th)*r, Math.sin(th)*r, rand(.7,1.3)); }
  for(let i=0;i<220;i++){ const r=rand(82,240), th=rand(0,Math.PI*2); if(Math.abs(r-TRACK_RADIUS)>10) addTree(Math.cos(th)*r, Math.sin(th)*r, rand(.6,1.1)); }

  // Cars + kids with faces
  const CAR_COUNT = 24;
  const CAR_SPACING = 2.2;
  const CAR_LEN = 1.8, CAR_W = 1.2, CAR_H = 0.7;
  const carMat = new THREE.MeshStandardMaterial({ color:0xbfc5cc, metalness:.85, roughness:.35, envMapIntensity:1.5 });

  function makeCoalCar(){
    const g = new THREE.Group();
    const shell = new THREE.Mesh(new THREE.BoxGeometry(CAR_LEN, CAR_H, CAR_W), carMat);
    shell.castShadow = shell.receiveShadow = true; g.add(shell);
    const inner = new THREE.Mesh(new THREE.BoxGeometry(CAR_LEN*0.96, CAR_H*0.6, CAR_W*0.96),
      new THREE.MeshStandardMaterial({ color:0xaeb4bb, metalness:.2, roughness:.9 }));
    inner.position.y = 0.05; inner.receiveShadow=true; g.add(inner);
    const wheelMat = new THREE.MeshStandardMaterial({ color:0x2d2f33, metalness:.5, roughness:.5, envMapIntensity:.6 });
    const wheel = ()=>{ const w=new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.22,0.28,16), wheelMat); w.rotation.z=Math.PI/2; w.castShadow=true; return w; };
    const w1=wheel(); w1.position.set(-0.6,-0.42, 0.55);
    const w2=wheel(); w2.position.set(-0.6,-0.42,-0.55);
    const w3=wheel(); w3.position.set( 0.6,-0.42, 0.55);
    const w4=wheel(); w4.position.set( 0.6,-0.42,-0.55);
    g.add(w1,w2,w3,w4);
    const coupler = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.1,0.1), new THREE.MeshStandardMaterial({color:0x444, roughness:.7}));
    coupler.position.x = CAR_LEN/2 + 0.1; g.add(coupler);
    return g;
  }

  // Shared tiny geometries/materials for faces (perf-friendly)
  const geoHead = new THREE.SphereGeometry(0.18, 16, 12);
  const matSkin = new THREE.MeshStandardMaterial({color:0xffd6b0, roughness:.6});
  const geoEye = new THREE.SphereGeometry(0.03, 10, 8);
  const matEye = new THREE.MeshStandardMaterial({color:0x111111, roughness:.5, metalness:0.1});
  const geoMouth = new THREE.CylinderGeometry(0.055, 0.055, 0.02, 16);
  const matMouth = new THREE.MeshStandardMaterial({color:0x843434, roughness:.6});
  const geoHairCapTop = new THREE.SphereGeometry(0.20, 16, 12);
  const geoHairBand = new THREE.CylinderGeometry(0.205, 0.205, 0.06, 16);

  function makeKidHead(){
    const g = new THREE.Group();

    // Head
    const head = new THREE.Mesh(geoHead, matSkin);
    head.position.y = 0.18;
    g.add(head);

    // Eyes
    const eyeL = new THREE.Mesh(geoEye, matEye);
    const eyeR = eyeL.clone();
    eyeL.position.set(-0.055, 0.21, 0.16);
    eyeR.position.set( 0.055, 0.21, 0.16);
    g.add(eyeL, eyeR);

    // Mouth (little cylinder flattened & rotated)
    const mouth = new THREE.Mesh(geoMouth, matMouth);
    mouth.rotation.x = Math.PI/2;
    mouth.scale.set(1.0, 0.65, 1.0);
    mouth.position.set(0, 0.13, 0.17);
    g.add(mouth);

    // Hair (random color)
    const hairColor = new THREE.Color().setHSL(Math.random()*0.12+0.05, 0.5, 0.25); // brownish range
    const matHair = new THREE.MeshStandardMaterial({color:hairColor, roughness:.8, metalness:0.05});
    const cap = new THREE.Mesh(geoHairCapTop, matHair);
    cap.scale.y = 0.6; // flatten to cap
    cap.position.y = 0.30;
    const band = new THREE.Mesh(geoHairBand, matHair);
    band.position.y = 0.25;
    g.add(cap, band);

    return g;
  }

  const train = new THREE.Group();
  const cars = [];
  for(let i=0;i<24;i++){
    const car = makeCoalCar();
    const k1 = makeKidHead(); k1.position.set(-0.3, 0.45,  0.22);
    const k2 = makeKidHead(); k2.position.set( 0.25, 0.45, -0.18);
    car.add(k1,k2);
    cars.push(car); train.add(car);
  }
  scene.add(train);

  // Helpers
  const ANGLE_PER_M = 1 / TRACK_RADIUS;           // rad per meter
  const CAR_SPACING = 2.2;
  const ARC_SPACING = CAR_SPACING * ANGLE_PER_M;  // rad between cars
  function placeCar(car, angle){
    const x = Math.cos(angle) * TRACK_RADIUS;
    const z = Math.sin(angle) * TRACK_RADIUS;
    const tx = -Math.sin(angle), tz = Math.cos(angle); // correct tangent
    car.position.set(x, 0, z);
    car.rotation.y = Math.atan2(tx, tz);
  }

  // Camera ride params — with Tall toggle
  const CAMERA_CAR_INDEX = 10;
  let yawDeg = 0;
  let targetEye = 0.62;         // seated height
  const SEATED = 0.62, TALL = 1.02;
  let isTall = false;

  function updateCamera(rideAng, time){
    const cx = Math.cos(rideAng) * TRACK_RADIUS;
    const cz = Math.sin(rideAng) * TRACK_RADIUS;
    const tx = -Math.sin(rideAng), tz = Math.cos(rideAng);
    const tangentY = Math.atan2(tx, tz);

    // smooth eye height to target
    const curY = camYaw.position.y || SEATED;
    const newY = curY + (targetEye - curY) * 0.12;

    camYaw.position.set(cx, newY + Math.sin(time*2.5)*0.015, cz); // tiny bob
    camYaw.rotation.y = tangentY + THREE.MathUtils.degToRad(yawDeg);
    camPitch.rotation.x = 0; // lock pitch so you can't look up/down
    camera.position.set(0,0,0);
  }

  // UI
  const $ = id=>document.getElementById(id);
  let mph = parseFloat($("speed").value);
  $("mph").textContent = String(mph);
  $("speed").addEventListener("input", ()=>{ mph=parseFloat($("speed").value); $("mph").textContent=String(mph); });

  // Look controls — keyboard (left/right ONLY)
  window.addEventListener("keydown", (e)=>{
    if(e.key === "ArrowLeft"){  yawDeg -= 4; }
    if(e.key === "ArrowRight"){ yawDeg += 4; }
  });

  // On‑screen look buttons (press‑and‑hold)
  function hold(btn, onTick){
    let t=null;
    const start=(ev)=>{ ev.preventDefault(); if(t) return; onTick(); t=setInterval(onTick, 80); };
    const stop =()=>{ clearInterval(t); t=null; };
    btn.addEventListener("pointerdown", start);
    btn.addEventListener("pointerup", stop);
    btn.addEventListener("pointerleave", stop);
    btn.addEventListener("pointercancel", stop);
  }
  hold($("padLeft"),  ()=>{ yawDeg -= 4; });
  hold($("padRight"), ()=>{ yawDeg += 4; });

  // Tall toggle
  $("tall").addEventListener("click", ()=>{
    isTall = !isTall;
    targetEye = isTall ? TALL : SEATED;
    $("tall").textContent = `Tall: ${isTall ? "On" : "Off"}`;
    $("tall").classList.toggle("ghost", !isTall);
  });

  // Audio
  const audio = new (window.AudioContext||window.webkitAudioContext)();
  const whistle = ()=>{
    const o=audio.createOscillator(), g=audio.createGain();
    g.gain.value=0.001; o.type='sine';
    o.frequency.setValueAtTime(720,audio.currentTime);
    o.frequency.exponentialRampToValueAtTime(1100,audio.currentTime+0.35);
    o.frequency.exponentialRampToValueAtTime(680,audio.currentTime+0.9);
    g.gain.exponentialRampToValueAtTime(0.5,audio.currentTime+0.04);
    g.gain.exponentialRampToValueAtTime(0.32,audio.currentTime+0.4);
    g.gain.exponentialRampToValueAtTime(0.001,audio.currentTime+1.0);
    o.connect(g).connect(audio.destination); o.start(); o.stop(audio.currentTime+1.05);
  };
  const bell = ()=>{
    const o1=audio.createOscillator(), o2=audio.createOscillator(), g=audio.createGain();
    o1.type=o2.type='sine'; o1.frequency.value=660; o2.frequency.value=990;
    g.gain.value=0.001;
    g.gain.exponentialRampToValueAtTime(0.35,audio.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.001,audio.currentTime+0.6);
    o1.connect(g); o2.connect(g); g.connect(audio.destination);
    o1.start(); o2.start(); o1.stop(audio.currentTime+0.65); o2.stop(audio.currentTime+0.65);
  };
  $("whistle").addEventListener("click", ()=>{ if(audio.state==='suspended') audio.resume(); whistle(); });
  $("bell").addEventListener("click", ()=>{ if(audio.state==='suspended') audio.resume(); bell(); });

  // Headline + Dark mode
  let headlineOn = true;
  document.getElementById("toggleHeadline").addEventListener("click", ()=>{
    headlineOn = !headlineOn;
    document.getElementById("headline").classList.toggle("hidden", !headlineOn);
    document.getElementById("toggleHeadline").textContent = `Headline: ${headlineOn ? "On" : "Off"}`;
  });
  const setDark = on=>{
    document.querySelector(".wrap").classList.toggle("dark", on);
    if(on){
      renderer.setClearColor(0x0b1220,1);
      hemi.intensity=.35; sun.intensity=1.4;
    } else {
      renderer.setClearColor(0xcfe8ff,1);
      hemi.intensity=.5; sun.intensity=2.0;
    }
  };
  setDark(false);
  document.getElementById("dark").addEventListener("click", ()=> setDark(!document.querySelector(".wrap").classList.contains("dark")));

  // Resize
  function fit(){
    const r = container.getBoundingClientRect();
    const w = Math.max(1,r.width), h = Math.max(1,r.height);
    camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false);
  }
  new ResizeObserver(fit).observe(container); fit();

  // Animate
  const clock = new THREE.Clock();
  let theta = 0;
  function animate(){
    const dt = clock.getDelta();
    const mps = (mph * 1609.344) / 3600;
    const angVel = mps / TRACK_RADIUS;
    theta += angVel * dt;

    // place cars (front at theta)
    for(let i=0;i<cars.length;i++){
      const ang = theta - i * (CAR_SPACING * ANGLE_PER_M);
      placeCar(cars[i], ang);
    }

    // camera ride (~10 cars back)
    const rideAng = theta - (10 * (CAR_SPACING * ANGLE_PER_M));
    updateCamera(rideAng, clock.elapsedTime);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  log("Look: ← → | Tall toggles eye height | Speed on slider");
})();
</script>
</body>
</html>
