<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Greenport Express — Miniature Railroad World</title>
<style>
  :root{--bg:#0b1220;--fg:#e5e7eb}
  html,body{height:100%;margin:0}
  body{font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0b1220;color:#e5e7eb}
  .wrap{position:fixed;inset:0;background:var(--bg);color:var(--fg)}
  .head{position:absolute;top:0;left:0;right:0;display:flex;align-items:center;justify-content:center;gap:12px;
        background:#fff;color:#0b1220;padding:10px 14px;box-shadow:0 10px 30px rgba(2,6,23,.12);z-index:3}
  .head h1{margin:0;font-size:18px}
  .badge{font-size:12px;color:#fff;background:linear-gradient(135deg,#0ea5e9,#22d3ee);padding:4px 8px;border-radius:999px}
  .headtoggle{position:absolute;left:14px}
  .scene{position:absolute;inset:44px 0 0 0}
  .hud{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);display:flex;align-items:center;gap:12px;
       padding:10px 12px;border-radius:14px;background:rgba(255,255,255,.95);backdrop-filter:blur(8px);
       box-shadow:0 10px 30px rgba(2,6,23,.15);z-index:3;color:#0b1220;flex-wrap:wrap}
  .ctl{display:grid;gap:6px;font-size:12px;color:#64748b}
  .sp{width:1px;align-self:stretch;background:rgba(100,116,139,.3)}
  .btn{appearance:none;border:0;background:#0ea5e9;color:#fff;padding:9px 12px;border-radius:12px;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(100,116,139,.4);color:#0b1220}
  .range{-webkit-appearance:none;appearance:none;width:220px;height:6px;border-radius:999px;background:rgba(100,116,139,.45)}
  .range::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:#0ea5e9;border:2px solid rgba(255,255,255,.9)}
  .hidden{display:none!important}
  #status{position:absolute;top:52px;left:12px;z-index:4;font-size:12px;color:#0369a1}

  /* Look pad (bottom-right) */
  .pad{position:absolute;right:14px;bottom:14px;z-index:3;display:grid;grid-template-columns:56px 56px 56px;grid-template-rows:56px 56px 56px;gap:8px}
  .pad button{appearance:none;border:0;border-radius:10px;background:rgba(255,255,255,.95);
              box-shadow:0 6px 18px rgba(2,6,23,.15);color:#0b1220;font-weight:700;cursor:pointer}
  .pad .blank{visibility:hidden}

  /* Score ribbon */
  .ribbon{position:absolute;top:52px;right:12px;z-index:4;background:rgba(255,255,255,.95);color:#0b1220;
          border-radius:12px;padding:10px 12px;box-shadow:0 10px 30px rgba(2,6,23,.15);min-width:220px}
  .ribbon .row{display:flex;align-items:center;justify-content:space-between;margin:2px 0}
  .tag{padding:2px 8px;border-radius:999px;background:#e2e8f0;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="head">
    <div class="headtoggle"><button id="toggleHeadline" class="ghost btn">Headline: On</button></div>
    <h1 id="headline">Greenport Express</h1>
    <span class="badge">Kids’ Miniature Railroad — Explore Greenport!</span>
  </div>

  <div id="status">Loading…</div>
  <div class="scene" id="scene"></div>

  <!-- Score / Mission -->
  <div class="ribbon">
    <div class="row"><strong>Score:</strong> <span id="score">0</span></div>
    <div class="row"><span class="tag">Shells</span><span id="shells">0 / 12</span></div>
    <div class="row"><span class="tag">Passengers</span><span id="pax">0</span></div>
    <hr style="border:none;border-top:1px solid #e5e7eb;margin:8px 0">
    <div style="font-size:12px;color:#334155">Daily Mission</div>
    <div id="mission" style="font-size:13px">Pick up 6 passengers at the Carnival.</div>
    <button id="reroll" class="btn ghost" style="margin-top:6px;padding:6px 10px">New Mission</button>
  </div>

  <!-- Main HUD -->
  <div class="hud">
    <div class="ctl">
      <label for="speed">Speed</label>
      <input id="speed" class="range" type="range" min="0" max="35" value="12" />
    </div>
    <div style="font-size:12px;color:#64748b"><strong id="mph">12</strong> mph</div>
    <div class="sp"></div>
    <button id="whistle" class="btn">Whistle</button>
    <button id="bell" class="btn ghost">Bell</button>
    <div class="sp"></div>
    <button id="dark" class="btn">Night</button>
    <button id="tall" class="btn ghost" title="See over the cars">Tall: Off</button>
    <button id="center" class="btn ghost">Center View</button>
    <button id="photo" class="btn ghost">Photo</button>
  </div>

  <!-- Look pad (↑ ↓ ← →) -->
  <div class="pad" aria-label="look controls">
    <span class="blank"></span><button id="padUp">↑</button><span class="blank"></span>
    <button id="padLeft">←</button><span class="blank"></span><button id="padRight">→</button>
    <span class="blank"></span><button id="padDown">↓</button><span class="blank"></span>
  </div>
</div>

<!-- Local Three.js only (no CDNs) -->
<script src="./three.min.js"></script>
<script>
(function(){
  const statusEl = document.getElementById('status');
  const setStatus = m => (statusEl.textContent = m);
  if(!window.THREE){ setStatus('ERROR: three.min.js not found next to index.html'); return; }
  const THREE = window.THREE;

  // ——— Setup ———
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  // Simple PMREM env
  const pmrem = new THREE.PMREMGenerator(renderer);
  const envC = document.createElement('canvas'); envC.width=envC.height=256;
  const eg = envC.getContext('2d'), g=eg.createLinearGradient(0,0,0,256);
  g.addColorStop(0,'#cfe8ff'); g.addColorStop(1,'#9fc3ff'); eg.fillStyle=g; eg.fillRect(0,0,256,256);
  const envTex = new THREE.CanvasTexture(envC); envTex.colorSpace = THREE.SRGBColorSpace;
  scene.environment = pmrem.fromEquirectangular(envTex).texture; envTex.dispose();

  // Camera rig: yaw -> pitch -> camera (so we can clamp pitch)
  const camera = new THREE.PerspectiveCamera(72, 1, 0.05, 2500);
  const camYaw = new THREE.Object3D();
  const camPitch = new THREE.Object3D();
  camYaw.add(camPitch); camPitch.add(camera);
  scene.add(camYaw);

  // Lights + day/night
  const hemi = new THREE.HemisphereLight(0xffffff, 0x2a3b2a, 0.6); scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 2.1);
  sun.position.set(90,140,60);
  sun.castShadow=true; sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.near=1; sun.shadow.camera.far=600;
  sun.shadow.camera.left=-160; sun.shadow.camera.right=160;
  sun.shadow.camera.top=160; sun.shadow.camera.bottom=-160; scene.add(sun);
  const nightGroup = new THREE.Group(); nightGroup.visible=false; scene.add(nightGroup);

  // Ground
  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(900, 128),
    new THREE.MeshStandardMaterial({ color:0x98cfa7, roughness:0.95 })
  );
  ground.rotation.x = -Math.PI/2; ground.receiveShadow=true; scene.add(ground);

  // Track
  const TRACK_RADIUS=85, GAUGE=0.6;
  function CirclePath(r){ this.radius=r; }
  CirclePath.prototype = Object.create(THREE.Curve.prototype);
  CirclePath.prototype.getPoint=function(t){ const a=t*Math.PI*2; return new THREE.Vector3(Math.cos(a)*this.radius,0,Math.sin(a)*this.radius); };
  const railMat = new THREE.MeshStandardMaterial({ color:0x7e8790, metalness:1.0, roughness:0.25, envMapIntensity:1.2 });
  const innerRail = new THREE.Mesh(new THREE.TubeGeometry(new CirclePath(TRACK_RADIUS-GAUGE/2),960,0.055,16,true), railMat);
  const outerRail = new THREE.Mesh(new THREE.TubeGeometry(new CirclePath(TRACK_RADIUS+GAUGE/2),960,0.055,16,true), railMat);
  innerRail.castShadow=outerRail.castShadow=true; innerRail.receiveShadow=outerRail.receiveShadow=true; scene.add(innerRail,outerRail);
  const ballast = new THREE.Mesh(new THREE.RingGeometry(TRACK_RADIUS-GAUGE/2-1.2, TRACK_RADIUS+GAUGE/2+1.2, 200),
                                 new THREE.MeshStandardMaterial({color:0x8e99a3, roughness:1}));
  ballast.geometry.rotateX(-Math.PI/2); ballast.receiveShadow=true; scene.add(ballast);

  // Trees (quick)
  const trunkGeo=new THREE.CylinderGeometry(0.35,0.45,2.8,10);
  const trunkMat=new THREE.MeshStandardMaterial({color:0x6b4f2c,roughness:.95});
  const foliageMat=new THREE.MeshStandardMaterial({color:0x2f7a4a,roughness:.9,metalness:0,envMapIntensity:0.2});
  const R=(a,b)=>a+Math.random()*(b-a);
  function addTree(x,z,s){
    const t=new THREE.Mesh(trunkGeo,trunkMat); t.scale.set(s,s,s); t.position.set(x,1.4*s,z); t.castShadow=t.receiveShadow=true; scene.add(t);
    [[1.7,3.0,3.0],[1.4,2.6,4.4],[1.1,2.2,5.7]].forEach(([r,h,y])=>{
      const c=new THREE.Mesh(new THREE.ConeGeometry(r*s,h*s,12), foliageMat); c.position.set(x,y*s,z); c.castShadow=true; scene.add(c);
    });
  }
  for(let i=0;i<900;i++){ const r=R(95,860), th=R(0,Math.PI*2); addTree(Math.cos(th)*r,Math.sin(th)*r,R(.6,1.25)); }
  for(let i=0;i<280;i++){ const r=R(110,280), th=R(0,Math.PI*2); if(Math.abs(r-TRACK_RADIUS)>12) addTree(Math.cos(th)*r,Math.sin(th)*r,R(.6,1.0)); }

  // POIs (Ferris, Skate, Lighthouse, Harbor) — unchanged from your last version for brevity
  // (kept minimal spinning/anim, lights at night)
  const POI=[]; function addPOI(name,ang,group){ POI.push({name,ang,group}); scene.add(group); }
  function placeAround(g,ang,r){ g.position.set(Math.cos(ang)*r,0,Math.sin(ang)*r); g.lookAt(0,0,0); }

  // Carnival / Ferris
  const carnival=new THREE.Group(), wheel=new THREE.Group(); const wheelR=7;
  wheel.add(new THREE.Mesh(new THREE.TorusGeometry(wheelR,0.18,8,48), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.4})));
  const hub=new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,2,16), new THREE.MeshStandardMaterial({color:0xaaaaaa, metalness:.6, roughness:.4}));
  hub.rotation.z=Math.PI/2; wheel.add(hub);
  for(let i=0;i<12;i++){
    const a=i/12*Math.PI*2;
    const car=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.7,0.8), new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL(i/12,0.6,0.55)}));
    car.position.set(Math.cos(a)*wheelR, Math.sin(a)*wheelR,0); wheel.add(car);
    const bulb=new THREE.Mesh(new THREE.SphereGeometry(0.18,10,10), new THREE.MeshStandardMaterial({emissive:new THREE.Color().setHSL(i/12,1,0.6), color:0x000, emissiveIntensity:2}));
    bulb.position.set(Math.cos(a)*wheelR*1.02, Math.sin(a)*wheelR*1.02, .2); nightGroup.add(bulb); bulb.position.add(carnival.position);
  }
  carnival.add(wheel);
  addPOI('Carnival', Math.PI*0.05, carnival);

  // Lighthouse + beam
  const lightHouse=new THREE.Group();
  const tower=new THREE.Mesh(new THREE.CylinderGeometry(1.5,2.2,12,16), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.9}));
  const cap=new THREE.Mesh(new THREE.ConeGeometry(1.8,2,16), new THREE.MeshStandardMaterial({color:0xcc0000, roughness:.6}));
  cap.position.y=7; tower.position.y=5; lightHouse.add(tower,cap);
  const beam=new THREE.SpotLight(0xffeeaa, 12, 120, Math.PI/16, 0.35, 1.0);
  beam.position.set(0,10.2,0); beam.target.position.set(10,9,0); nightGroup.add(beam, beam.target);
  addPOI('Lighthouse', Math.PI*0.62, lightHouse);

  // Harbor
  const harbor=new THREE.Group();
  const water=new THREE.Mesh(new THREE.CircleGeometry(55,48), new THREE.MeshStandardMaterial({color:0x69b3ff, metalness:.1, roughness:.4}));
  water.rotation.x=-Math.PI/2; harbor.add(water);
  function boat(col){ const g=new THREE.Group();
    const hull=new THREE.Mesh(new THREE.CapsuleGeometry(2.4,4.0,4,12), new THREE.MeshStandardMaterial({color:col, roughness:.7, metalness:.2}));
    hull.rotation.z=Math.PI/2; g.add(hull);
    const cab=new THREE.Mesh(new THREE.BoxGeometry(1.6,1,1.2), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.9})); cab.position.set(0.6,0.9,0); g.add(cab);
    return g;
  }
  const boat1=boat(0x0ea5e9), boat2=boat(0x22c55e), boat3=boat(0xf97316);
  boat1.position.set(-10,0,10); boat2.position.set(8,0,-6); boat3.position.set(12,0,14); harbor.add(boat1,boat2,boat3);
  addPOI('Harbor', Math.PI*0.80, harbor);

  // Skate (simple)
  const skate=new THREE.Group();
  const rampMat=new THREE.MeshStandardMaterial({color:0xbfc9d1, roughness:.8});
  const ramp=new THREE.Mesh(new THREE.CylinderGeometry(4,4,6,24,1,true,0,Math.PI/2), rampMat);
  ramp.rotation.z=Math.PI/2; ramp.position.set(0,0,3);
  const rampB=ramp.clone(); rampB.position.set(0,0,-3); rampB.rotation.y=Math.PI;
  const skater=new THREE.Mesh(new THREE.BoxGeometry(0.8,1.2,0.4), new THREE.MeshStandardMaterial({color:0x1e293b}));
  skater.position.y=0.8; skate.add(ramp,rampB,skater);
  addPOI('Skate Park', Math.PI*0.38, skate);

  POI.forEach(p=>placeAround(p.group, p.ang, TRACK_RADIUS+18));

  // Train + kids (same as last version)
  const CAR_CT=24, CAR_SP=2.2;
  const carMat=new THREE.MeshStandardMaterial({ color:0xbfc5cc, metalness:.85, roughness:.35, envMapIntensity:1.5 });
  function coalCar(){
    const g=new THREE.Group();
    const shell=new THREE.Mesh(new THREE.BoxGeometry(1.8,0.7,1.2),carMat); shell.castShadow=shell.receiveShadow=true; g.add(shell);
    const inner=new THREE.Mesh(new THREE.BoxGeometry(1.73,0.42,1.12), new THREE.MeshStandardMaterial({color:0xaeb4bb, metalness:.2, roughness:.9}));
    inner.position.y=0.05; inner.receiveShadow=true; g.add(inner);
    const wm=new THREE.MeshStandardMaterial({color:0x2d2f33, metalness:.5, roughness:.5});
    const wheel=(x,z)=>{const w=new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.22,0.28,16),wm); w.rotation.z=Math.PI/2; w.position.set(x,-0.42,z); w.castShadow=true; g.add(w);};
    wheel(-0.6, 0.55); wheel(-0.6,-0.55); wheel(0.6,0.55); wheel(0.6,-0.55);
    const coupler=new THREE.Mesh(new THREE.BoxGeometry(0.2,0.1,0.1), new THREE.MeshStandardMaterial({color:0x444, roughness:.7}));
    coupler.position.x=1.0; g.add(coupler); return g;
  }
  const geoHead=new THREE.SphereGeometry(0.18,16,12), skin=new THREE.MeshStandardMaterial({color:0xffd6b0, roughness:.6});
  const geoEye=new THREE.SphereGeometry(0.03,10,8), eyeM=new THREE.MeshStandardMaterial({color:0x111});
  const geoMouth=new THREE.CylinderGeometry(0.055,0.055,0.02,16), mouthM=new THREE.MeshStandardMaterial({color:0x843434, roughness:.6});
  const geoCap=new THREE.SphereGeometry(0.20,16,12), geoBand=new THREE.CylinderGeometry(0.205,0.205,0.06,16);
  function kid(){
    const g=new THREE.Group(); const h=new THREE.Mesh(geoHead,skin); h.position.y=0.18; g.add(h);
    const e1=new THREE.Mesh(geoEye,eyeM), e2=e1.clone(); e1.position.set(-0.055,0.21,0.16); e2.position.set(0.055,0.21,0.16); g.add(e1,e2);
    const m=new THREE.Mesh(geoMouth,mouthM); m.rotation.x=Math.PI/2; m.scale.set(1,.65,1); m.position.set(0,0.13,0.17); g.add(m);
    const hc=new THREE.Color().setHSL(Math.random()*0.12+0.05,0.5,0.25);
    const hairM=new THREE.MeshStandardMaterial({color:hc, roughness:.8, metalness:0.05});
    const cap=new THREE.Mesh(geoCap,hairM); cap.scale.y=.6; cap.position.y=.30;
    const band=new THREE.Mesh(geoBand,hairM); band.position.y=.25; g.add(cap,band); return g;
  }
  const train=new THREE.Group(), cars=[];
  for(let i=0;i<CAR_CT;i++){ const c=coalCar(); const k1=kid(); k1.position.set(-0.3,0.45,0.22); const k2=kid(); k2.position.set(0.25,0.45,-0.18); c.add(k1,k2); cars.push(c); train.add(c); }
  scene.add(train);

  // Helpers
  const ANGLE_PER_M = 1 / TRACK_RADIUS;
  const ARC_SPACING = CAR_SP * ANGLE_PER_M;
  function placeCar(car, angle){
    const x = Math.cos(angle)*TRACK_RADIUS, z = Math.sin(angle)*TRACK_RADIUS;
    const tx = -Math.sin(angle), tz = Math.cos(angle);
    car.position.set(x,0,z);
    car.rotation.y = Math.atan2(tx,tz);
  }

  // Collectibles (shells) + stops (kept simple)
  const shellsGroup=new THREE.Group(); scene.add(shellsGroup);
  const shellM=new THREE.MeshStandardMaterial({color:0xfff3bf, metalness:.2, roughness:.5, emissive:0x665500, emissiveIntensity:.08});
  const shellG=new THREE.SphereGeometry(0.12,12,10);
  const shellAngles=[]; const SHELL_CT=12;
  for(let i=0;i<SHELL_CT;i++){ const a=Math.random()*Math.PI*2, r=TRACK_RADIUS+(Math.random()<.5?-1.2:1.2);
    const s=new THREE.Mesh(shellG,shellM); s.position.set(Math.cos(a)*r,0.12,Math.sin(a)*r); s.userData.ang=a; shellsGroup.add(s); shellAngles.push(a);}
  const stops=[];
  function addStop(name,ang){ const g=new THREE.Group();
    const p=new THREE.Mesh(new THREE.BoxGeometry(3.5,0.2,1.2), new THREE.MeshStandardMaterial({color:0x333, roughness:.9}));
    g.add(p); placeAround(g,ang,TRACK_RADIUS-2.2); scene.add(g); stops.push({name,ang,group:g}); }
  addStop('Carnival Station', Math.PI*0.05+0.03);
  addStop('Harbor Dock', Math.PI*0.80+0.06);

  // ——— UI state ———
  const $=id=>document.getElementById(id);
  let mph=parseFloat($("speed").value); $("mph").textContent=String(mph);
  $("speed").addEventListener("input",()=>{ mph=parseFloat($("speed").value); $("mph").textContent=String(mph); });

  let yawDeg=0, pitchDeg=0;                       // now both axes
  const PITCH_MIN = -60, PITCH_MAX = 60;          // degrees
  let targetEye=0.62, isTall=false; const SEATED=0.62, TALL=1.05;
  let score=0, shells=0, pax=0;
  const incScore=n=>{ score+=n; $("score").textContent=String(score); };
  const setShells=()=>{ $("shells").textContent=`${shells} / ${SHELL_CT}`; };
  const setPax=()=>{ $("pax").textContent=String(pax); };

  // Missions
  const missions=['Pick up 6 passengers at the Carnival.','Collect 5 shells near the Harbor.','Finish a lap under 2:30 minutes.','Whistle at the Lighthouse and Skate Park.'];
  function reroll(){ $("mission").textContent = missions[Math.floor(Math.random()*missions.length)]; }
  reroll(); $("reroll").addEventListener("click", reroll);

  // ——— Lightweight Orbit‑style controls (mouse/touch) ———
  (function attachLookControls(){
    const el = renderer.domElement;
    let dragging=false, lastX=0, lastY=0;
    const rotSpeed = 0.18; // degrees per pixel
    const onDown = e => { dragging=true; const p=point(e); lastX=p.x; lastY=p.y; el.setPointerCapture?.(e.pointerId||0); };
    const onMove = e => {
      if(!dragging) return; const p=point(e);
      const dx=p.x-lastX, dy=p.y-lastY; lastX=p.x; lastY=p.y;
      yawDeg   += dx*rotSpeed;
      pitchDeg -= dy*rotSpeed;
      pitchDeg = Math.max(PITCH_MIN, Math.min(PITCH_MAX, pitchDeg));
    };
    const onUp = () => { dragging=false; };
    function point(e){ if(e.touches&&e.touches[0]) return {x:e.touches[0].clientX,y:e.touches[0].clientY}; return {x:e.clientX,y:e.clientY}; }
    el.addEventListener('pointerdown',onDown); el.addEventListener('pointermove',onMove); el.addEventListener('pointerup',onUp); el.addEventListener('pointerleave',onUp);
    el.addEventListener('touchstart',onDown,{passive:false}); el.addEventListener('touchmove',onMove,{passive:false}); el.addEventListener('touchend',onUp);
  })();

  // Keyboard arrows
  window.addEventListener('keydown',e=>{
    const step=4;
    if(e.key==='ArrowLeft')  yawDeg-=step;
    if(e.key==='ArrowRight') yawDeg+=step;
    if(e.key==='ArrowUp')  { pitchDeg=Math.min(PITCH_MAX, pitchDeg+step); }
    if(e.key==='ArrowDown'){ pitchDeg=Math.max(PITCH_MIN, pitchDeg-step); }
  });

  // On‑screen pad (hold to repeat)
  function hold(btn,fn){ let t=null;
    const start=ev=>{ev.preventDefault(); if(t) return; fn(); t=setInterval(fn,80); };
    const stop =()=>{ clearInterval(t); t=null; };
    btn.addEventListener('pointerdown',start); btn.addEventListener('pointerup',stop);
    btn.addEventListener('pointerleave',stop); btn.addEventListener('pointercancel',stop);
  }
  hold($("padLeft"), ()=>{yawDeg-=4});  hold($("padRight"), ()=>{yawDeg+=4});
  hold($("padUp"),   ()=>{pitchDeg=Math.min(PITCH_MAX, pitchDeg+3)});
  hold($("padDown"), ()=>{pitchDeg=Math.max(PITCH_MIN, pitchDeg-3)});

  // Tall + center
  $("tall").addEventListener("click", ()=>{
    isTall=!isTall; targetEye=isTall?TALL:SEATED;
    $("tall").textContent=`Tall: ${isTall?'On':'Off'}`; $("tall").classList.toggle('ghost', !isTall);
  });
  $("center").addEventListener("click", ()=>{ yawDeg=0; pitchDeg=0; });

  // Night / Day
  let isNight=false;
  function setNight(on){
    isNight=on; nightGroup.visible=on;
    if(on){ renderer.setClearColor(0x06101f,1); hemi.intensity=.25; sun.intensity=1.1; }
    else { renderer.setClearColor(0xcfe8ff,1); hemi.intensity=.6; sun.intensity=2.1; }
    $("dark").textContent = on? 'Day' : 'Night';
  }
  setNight(false); $("dark").addEventListener("click",()=>setNight(!isNight));

  // Headline
  let headlineOn=true; $("toggleHeadline").addEventListener("click",()=>{ headlineOn=!headlineOn; $("headline").classList.toggle("hidden",!headlineOn); $("toggleHeadline").textContent=`Headline: ${headlineOn?'On':'Off'}`; });

  // Audio
  const audio=new (window.AudioContext||window.webkitAudioContext)();
  const whistle=()=>{const o=audio.createOscillator(),g=audio.createGain();g.gain.value=.001;o.type='sine';o.frequency.setValueAtTime(720,audio.currentTime);
    o.frequency.exponentialRampToValueAtTime(1100,audio.currentTime+.35);o.frequency.exponentialRampToValueAtTime(680,audio.currentTime+.9);
    g.gain.exponentialRampToValueAtTime(.5,audio.currentTime+.04);g.gain.exponentialRampToValueAtTime(.32,audio.currentTime+.4);g.gain.exponentialRampToValueAtTime(.001,audio.currentTime+1.0);
    o.connect(g).connect(audio.destination);o.start();o.stop(audio.currentTime+1.05);};
  const bell=()=>{const o1=audio.createOscillator(),o2=audio.createOscillator(),g=audio.createGain();o1.type=o2.type='sine';o1.frequency.value=660;o2.frequency.value=990;g.gain.value=.001;
    g.gain.exponentialRampToValueAtTime(.35,audio.currentTime+.02);g.gain.exponentialRampToValueAtTime(.001,audio.currentTime+.6);
    o1.connect(g);o2.connect(g);g.connect(audio.destination);o1.start();o2.start();o1.stop(audio.currentTime+.65);o2.stop(audio.currentTime+.65);};
  $("whistle").addEventListener("click",()=>{ if(audio.state==='suspended') audio.resume(); whistle(); });
  $("bell").addEventListener("click",()=>{ if(audio.state==='suspended') audio.resume(); bell(); });

  // Photo
  $("photo").addEventListener("click",()=>{ const a=document.createElement('a'); a.download='greenport-express.png'; a.href=renderer.domElement.toDataURL('image/png'); a.click(); });

  // Resize
  function fit(){ const r=container.getBoundingClientRect(); const w=Math.max(1,r.width), h=Math.max(1,r.height);
    camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); }
  new ResizeObserver(fit).observe(container); fit();

  // Animate
  const clock=new THREE.Clock(); let theta=0;
  const CAR_COUNT=24; // for readability in camera math
  function animate(){
    const dt=clock.getDelta();
    const mph = parseFloat(document.getElementById('speed').value);
    document.getElementById('mph').textContent = String(mph);
    const mps=(mph*1609.344)/3600, angVel=mps/TRACK_RADIUS; theta += angVel*dt;

    // move cars
    for(let i=0;i<CAR_CT;i++){ placeCar(cars[i], theta - i*ARC_SPACING); }

    // camera position — ride 10 cars back
    const rideAng = theta - (10*ARC_SPACING);
    const cx=Math.cos(rideAng)*TRACK_RADIUS, cz=Math.sin(rideAng)*TRACK_RADIUS;
    camYaw.position.set(cx, (camYaw.position.y||SEATED) + (targetEye-(camYaw.position.y||SEATED))*0.12 + Math.sin(clock.elapsedTime*2.5)*0.015, cz);
    // apply yaw/pitch
    const tx=-Math.sin(rideAng), tz=Math.cos(rideAng);
    const tangentY = Math.atan2(tx,tz);
    camYaw.rotation.y = tangentY + THREE.MathUtils.degToRad(yawDeg);
    camPitch.rotation.x = THREE.MathUtils.degToRad(pitchDeg);
    camera.position.set(0,0,0);

    // POI animation
    wheel.rotation.z += 0.35*dt;
    skater.position.x = Math.sin(clock.elapsedTime*1.3)*2.6;
    [boat1,boat2,boat3].forEach((b,i)=>{ b.position.y=Math.sin(clock.elapsedTime*1.2+i)*0.12; b.rotation.y+=0.15*dt; });
    if(nightGroup.visible){ beam.target.position.set(Math.cos(clock.elapsedTime*0.5)*40,6,Math.sin(clock.elapsedTime*0.5)*40); }

    // collectibles + stops
    const trainPos=new THREE.Vector3(cx,0,cz);
    shellsGroup.children.forEach(m=>{ if(m.visible && m.position.distanceTo(trainPos)<1.2){ m.visible=false; shells++; setShells(); incScore(50);} });
    stops.forEach(s=>{ const d=Math.abs(Math.atan2(Math.sin(rideAng-s.ang), Math.cos(rideAng-s.ang))); if(d<0.03 && mps>0.1){ pax++; setPax(); incScore(100); s.ang += 0.8 + Math.random()*0.6; placeAround(s.group, s.ang, TRACK_RADIUS-2.2); } });

    renderer.render(scene,camera); requestAnimationFrame(animate);
  }
  animate();

  setStatus('Use mouse/touch to look (up/down/left/right). Arrows work too. Tall toggles eye height.');
})();
</script>
</body>
</html>
