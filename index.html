<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Coal Train Balloon Pop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    :root {
      --bg: #cfe9ff;
      --ui: #0f172a;
      --ui2:#334155;
      --accent:#10b981;
      --gold:#fbbf24;
    }
    html, body {
      margin: 0; padding: 0; height: 100%;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--ui);
      background: linear-gradient(#bfe1ff, #e6f5ff 60%, #f5fbff);
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100dvh; gap: 8px;
      max-width: 1100px; margin: 0 auto; padding: 12px;
    }
    header, footer {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      background: white; border: 1px solid #e2e8f0; border-radius: 14px; padding: 10px 14px;
      box-shadow: 0 6px 20px rgba(15,23,42,.06);
    }
    header h1 { font-size: 20px; margin: 0; font-weight: 700; letter-spacing:.2px; }
    .btn {
      border: 1px solid #94a3b8; background: #f8fafc; color: var(--ui);
      padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600;
    }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: var(--accent); border-color: #059669; color: white; }
    .hud {
      display: flex; gap: 14px; align-items: center; flex-wrap: wrap;
      color: var(--ui2); font-weight: 700;
    }
    #game {
      width: 100%; aspect-ratio: 16/9; background: var(--bg);
      display: block; border-radius: 16px; border: 1px solid #dbeafe;
      box-shadow: 0 10px 30px rgba(2,6,23,.08);
      touch-action: none;  /* smoother pointer events on mobile */
    }
    .help {
      font-size: 14px; color:#475569;
    }
    .kbd {
      border: 1px solid #cbd5e1; background: #f8fafc; border-bottom-width: 3px; padding: 2px 6px; border-radius: 6px;
      font-weight: 700; font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ðŸš‚ Coal Train Balloon Pop</h1>
      <div class="hud">
        <span>Score: <span id="score">0</span></span>
        <span>Level: <span id="level">1</span></span>
        <span>Time: <span id="time">60</span>s</span>
        <button id="pauseBtn" class="btn">Pause</button>
        <button id="muteBtn" class="btn">Mute</button>
        <button id="restartBtn" class="btn primary">Restart</button>
      </div>
    </header>

    <canvas id="game" width="1280" height="720" aria-label="Balloon popping game canvas"></canvas>

    <footer>
      <div class="help">
        Aim with mouse/touch and <span class="kbd">Click/Tap</span> to shoot.
        <span class="kbd">Space</span> shoots too. Bonus waves appear sometimes!
      </div>
      <div class="help">Built for web embedding â€” single file, no external assets.</div>
    </footer>
  </div>

  <script>
    // ------------------ Basic Canvas Setup ------------------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Resize canvas to fit element size while keeping resolution crisp
    function fitCanvas() {
      const rect = canvas.getBoundingClientRect();
      const scale = devicePixelRatio || 1;
      canvas.width = Math.floor(rect.width * scale);
      canvas.height = Math.floor(rect.height * scale);
    }
    new ResizeObserver(fitCanvas).observe(canvas);
    fitCanvas();

    // ------------------ Game State ------------------
    let running = true;
    let muted = false;

    const uiScore = document.getElementById('score');
    const uiLevel = document.getElementById('level');
    const uiTime  = document.getElementById('time');

    const pauseBtn = document.getElementById('pauseBtn');
    const muteBtn  = document.getElementById('muteBtn');
    const restartBtn = document.getElementById('restartBtn');

    let gameState;

    function resetGame() {
      gameState = {
        score: 0,
        level: 1,
        timeLeft: 60, // seconds per level
        lastTimeUpdate: performance.now(),
        pointer: { x: canvas.width*0.25, y: canvas.height*0.6 },
        bullets: [],
        balloons: [],
        particles: [],
        bonusMode: false,
        bonusTimer: 0,
        trackOffset: 0,
        treesOffset: 0,
        farTreesOffset: 0,
        cloudsOffset: 0,
        shootCooldown: 0,
        goldenChance: 0.06,
      };
      uiScore.textContent = 0;
      uiLevel.textContent = 1;
      uiTime.textContent = 60;
      running = true;
    }
    resetGame();

    // ------------------ Input ------------------
    function canvasToGameCoords(e) {
      const rect = canvas.getBoundingClientRect();
      const scale = canvas.width / rect.width;
      const x = (e.clientX - rect.left) * scale;
      const y = (e.clientY - rect.top) * scale;
      return { x, y };
    }
    canvas.addEventListener('pointermove', e => {
      gameState.pointer = canvasToGameCoords(e);
    });
    canvas.addEventListener('pointerdown', e => {
      gameState.pointer = canvasToGameCoords(e);
      shoot();
    });
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { shoot(); }
      if (e.key.toLowerCase() === 'p') togglePause();
      if (e.key.toLowerCase() === 'm') toggleMute();
    });

    pauseBtn.onclick = togglePause;
    muteBtn.onclick = toggleMute;
    restartBtn.onclick = resetGame;
    function togglePause() {
      running = !running;
      pauseBtn.textContent = running ? 'Pause' : 'Resume';
      if (running) lastFrame = performance.now(); // smooth resume
    }
    function toggleMute() {
      muted = !muted;
      muteBtn.textContent = muted ? 'Unmute' : 'Mute';
    }

    // ------------------ Audio (tiny synth) ------------------
    let ac;
    function ensureAudio() {
      if (!ac) {
        try { ac = new (window.AudioContext || window.webkitAudioContext)(); }
        catch(_) { ac = null; }
      }
      return ac;
    }
    function beep(freq=600, dur=0.06, type='triangle', gain=0.03) {
      if (muted || !ensureAudio()) return;
      const t0 = ac.currentTime;
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g); g.connect(ac.destination);
      o.start(t0); o.stop(t0+dur+0.01);
    }
    function popSound(golden=false) {
      beep(golden ? 880 : 720, golden ? 0.12 : 0.08, 'square', golden?0.05:0.035);
    }
    function shootSound() {
      beep(240, 0.05, 'sawtooth', 0.03);
    }
    function levelUpSound() {
      beep(660, 0.08); setTimeout(()=>beep(880,0.08), 80);
    }

    // ------------------ Entities ------------------
    function spawnBalloon(isBonus=false) {
      const w = canvas.width, h = canvas.height;
      const x = Math.random() * (w * 0.9 - w*0.1) + w*0.1;
      const speed = isBonus ? (h*0.15 + Math.random()*h*0.1) : (h*0.05 + Math.random()*h*0.06 + gameState.level*0.003*h);
      const golden = !isBonus && Math.random() < gameState.goldenChance;
      const hue = golden ? 45 : Math.floor(Math.random()*360);
      const radius = golden ? h*0.03 : h*(0.022 + Math.random()*0.02);
      gameState.balloons.push({
        x, y: h + radius + Math.random()*h*0.15,
        vy: -speed,
        r: radius,
        hue, golden, wob: Math.random()*Math.PI*2,
      });
    }

    function shoot() {
      const now = performance.now();
      if (now < gameState.shootCooldown) return;
      gameState.shootCooldown = now + 110; // ms
      const train = trainPos();
      const ang = Math.atan2(gameState.pointer.y - train.cannonY, gameState.pointer.x - train.cannonX);
      const speed = canvas.height * 0.6;
      gameState.bullets.push({
        x: train.cannonX, y: train.cannonY,
        vx: Math.cos(ang) * speed,
        vy: Math.sin(ang) * speed,
        life: 0
      });
      shootSound();
    }

    // ------------------ Parallax / Train ------------------
    function trainPos() {
      const h = canvas.height, w = canvas.width;
      const baseY = h * 0.72;
      const x = w*0.18 + Math.sin(performance.now()/600)*w*0.005; // subtle bobble
      const cannonX = x + w*0.06, cannonY = baseY - h*0.08;
      return { x, y: baseY, cannonX, cannonY };
    }

    // ------------------ Particles ------------------
    function burst(x,y,color,count=16) {
      for (let i=0;i<count;i++){
        const a = Math.random()*Math.PI*2;
        const s = (Math.random()*0.5+0.5)* (canvas.height*0.25);
        gameState.particles.push({
          x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
          life: 0, maxLife: 0.5 + Math.random()*0.5,
          color
        });
      }
    }

    // ------------------ Update & Draw ------------------
    let lastFrame = performance.now();

    function update(dt) {
      // Time
      const now = performance.now();
      if (now - gameState.lastTimeUpdate >= 1000 && running) {
        gameState.lastTimeUpdate = now;
        gameState.timeLeft = Math.max(0, gameState.timeLeft - 1);
        uiTime.textContent = gameState.timeLeft;
        if (gameState.timeLeft === 0) {
          // Level complete or game over (after level 5 we end)
          if (gameState.level % 3 === 0) { // after bonus, ensure reset
            gameState.bonusMode = false;
          }
          if (gameState.level >= 5) {
            running = false; // game over state
          } else {
            gameState.level++;
            uiLevel.textContent = gameState.level;
            levelUpSound();
            // Bonus every 3rd level
            if (gameState.level % 3 === 0) {
              gameState.bonusMode = true;
              gameState.bonusTimer = 12; // seconds
            }
            gameState.timeLeft = 60;
            uiTime.textContent = gameState.timeLeft;
          }
        }
      }

      // Parallax scroll offsets
      const base = canvas.width * 0.12 * dt;
      gameState.cloudsOffset = (gameState.cloudsOffset + base*0.15) % canvas.width;
      gameState.farTreesOffset = (gameState.farTreesOffset + base*0.35) % canvas.width;
      gameState.treesOffset = (gameState.treesOffset + base*0.6) % canvas.width;
      gameState.trackOffset = (gameState.trackOffset + base*0.9) % canvas.width;

      // Spawning balloons
      const spawnRate = gameState.bonusMode ? 0.028 : (0.012 + gameState.level*0.0018);
      if (Math.random() < spawnRate * (dt*60)) spawnBalloon(gameState.bonusMode);

      // Bonus timer
      if (gameState.bonusMode) {
        gameState.bonusTimer -= dt;
        if (gameState.bonusTimer <= 0) gameState.bonusMode = false;
      }

      // Update bullets
      gameState.bullets.forEach(b=>{
        b.x += b.vx*dt; b.y += b.vy*dt; b.life += dt;
      });
      gameState.bullets = gameState.bullets.filter(b => b.life < 1.5 &&
        b.x>-50 && b.x<canvas.width+50 && b.y>-50 && b.y<canvas.height+50);

      // Update balloons
      gameState.balloons.forEach(b=>{
        b.wob += dt*3;
        b.x += Math.sin(b.wob)* (canvas.width*0.02 * dt);
        b.y += b.vy*dt;
      });
      // Remove offscreen (popped or flew away)
      gameState.balloons = gameState.balloons.filter(b => b.y + b.r > -40);

      // Collisions
      for (let i = gameState.balloons.length - 1; i >= 0; i--) {
        const bl = gameState.balloons[i];
        for (let j = gameState.bullets.length - 1; j >= 0; j--) {
          const bu = gameState.bullets[j];
          const dx = bl.x - bu.x, dy = bl.y - bu.y;
          if (dx*dx + dy*dy < (bl.r*bl.r)) {
            // hit!
            gameState.bullets.splice(j,1);
            gameState.balloons.splice(i,1);
            const pts = bl.golden ? 100 : 20;
            gameState.score += pts;
            uiScore.textContent = gameState.score;
            popSound(bl.golden);
            const color = bl.golden ? `hsl(45 95% 55%)` : `hsl(${bl.hue} 85% 60%)`;
            burst(bl.x, bl.y, color, bl.golden?28:16);
            break;
          }
        }
      }

      // Update particles
      gameState.particles.forEach(p=>{
        p.x += p.vx*dt; p.y += p.vy*dt;
        p.vx *= (1 - 1.6*dt); p.vy = p.vy* (1 - 1.8*dt) + 300*dt; // drag+gravity
        p.life += dt;
      });
      gameState.particles = gameState.particles.filter(p => p.life < p.maxLife);
    }

    function draw() {
      const w = canvas.width, h = canvas.height;

      // Sky
      const skyGrad = ctx.createLinearGradient(0,0,0,h);
      skyGrad.addColorStop(0, '#bfe1ff');
      skyGrad.addColorStop(1, '#eaf7ff');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0,0,w,h);

      // Clouds
      drawRepeatingLayer(gameState.cloudsOffset, w, (x)=>drawClouds(x, h*0.15));

      // Far trees
      drawRepeatingLayer(gameState.farTreesOffset, w, (x)=>drawTrees(x, h*0.62, h*0.28, 0.45));

      // Mid trees
      drawRepeatingLayer(gameState.treesOffset, w, (x)=>drawTrees(x, h*0.68, h*0.34, 0.8));

      // Ground
      ctx.fillStyle = '#9be28c';
      ctx.fillRect(0, h*0.7, w, h*0.3);

      // Track (parallax ties)
      drawTrack(gameState.trackOffset);

      // Balloons
      gameState.balloons.forEach(b=>{
        drawBalloon(b.x, b.y, b.r, b.golden ? 'hsl(45 95% 55%)' : `hsl(${b.hue} 85% 60%)`);
      });

      // Train
      drawTrain();

      // Bullets
      ctx.fillStyle = '#1f2937';
      gameState.bullets.forEach(b=>{
        ctx.beginPath();
        ctx.arc(b.x, b.y, h*0.006, 0, Math.PI*2);
        ctx.fill();
      });

      // Particles
      gameState.particles.forEach(p=>{
        const a = 1 - (p.life/p.maxLife);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = a;
        ctx.fillRect(p.x, p.y, h*0.006, h*0.006);
        ctx.globalAlpha = 1;
      });

      // Bonus banner
      if (gameState.bonusMode) {
        const t = `BONUS WAVE: ${Math.ceil(gameState.bonusTimer)}s`;
        banner(t, '#f59e0b');
      }

      // Pause overlay
      if (!running) {
        overlay();
        const title = gameState.timeLeft===0 && gameState.level>=5 ? "You did it!" : "Paused";
        bigText(title);
        smallText("Click Restart or press P to resume.");
      }

      // Game over overlay (after final level)
      if (!running && gameState.timeLeft===0 && gameState.level>=5) {
        overlay(0.7);
        bigText("ðŸŽ‰ Great Job!");
        smallText(`Final Score: ${gameState.score}`);
        smallText("Press Restart to play again.");
      }
    }

    function drawRepeatingLayer(offset, width, drawFn) {
      drawFn(-offset);
      drawFn(width - offset);
    }

    function drawClouds(xOffset, height) {
      const ctx2 = ctx, y = height;
      ctx2.fillStyle = 'rgba(255,255,255,0.9)';
      for (let i=0;i<6;i++){
        const x = xOffset + i * (canvas.width/6);
        cloudBlob(x, y + Math.sin((i+performance.now()/1000))*10, 80, 3+i%2);
      }
    }
    function cloudBlob(x,y,r,k=3){
      ctx.beginPath();
      for (let i=0;i<k;i++){
        ctx.arc(x + i*r*0.6, y, r*(0.7+0.2*Math.sin(i)), 0, Math.PI*2);
      }
      ctx.fill();
    }

    function drawTrees(xOffset, baseY, height, density=0.7) {
      for (let i=0;i<Math.floor(12*density); i++){
        const x = xOffset + i*(canvas.width/12);
        const trunkW = canvas.width*0.01;
        const trunkH = height*0.4;
        ctx.fillStyle = '#7c4a1b';
        ctx.fillRect(x, baseY - trunkH, trunkW, trunkH);
        const crownR = height*0.25 + (i%2)*height*0.08;
        ctx.fillStyle = '#2e7d32';
        ctx.beginPath();
        ctx.arc(x + trunkW/2, baseY - trunkH, crownR, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawTrack(offset) {
      const w = canvas.width, h = canvas.height;
      const y = h*0.76;
      // Rails
      ctx.strokeStyle = '#5b6b73'; ctx.lineWidth = h*0.01;
      ctx.beginPath();
      ctx.moveTo(0,y); ctx.lineTo(w,y);
      ctx.moveTo(0,y+h*0.06); ctx.lineTo(w,y+h*0.06);
      ctx.stroke();
      // Ties
      const spacing = w*0.08;
      for (let x=-offset; x<w; x+=spacing) {
        ctx.fillStyle = '#7c4a1b';
        ctx.fillRect(x, y-h*0.005, h*0.02, h*0.07);
      }
    }

    function drawBalloon(x,y,r,color) {
      ctx.save();
      ctx.fillStyle = color;
      // body
      ctx.beginPath(); ctx.ellipse(x,y,r*0.9,r,0,0,Math.PI*2); ctx.fill();
      // knot
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath(); ctx.moveTo(x,y+r*0.9); ctx.lineTo(x-r*0.12,y+r*1.08); ctx.lineTo(x+r*0.12,y+r*1.08); ctx.closePath(); ctx.fill();
      // shine
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = 'white';
      ctx.beginPath(); ctx.ellipse(x-r*0.3,y-r*0.3,r*0.25,r*0.15, -0.6, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      // string
      ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = Math.max(1, r*0.06);
      ctx.beginPath(); ctx.moveTo(x, y+r*1.05);
      ctx.quadraticCurveTo(x+r*0.2, y+r*1.4, x+r*0.05, y+r*1.8);
      ctx.stroke();
      ctx.restore();
    }

    function drawTrain() {
      const {x,y,cannonX,cannonY} = trainPos();
      const w = canvas.width, h = canvas.height;

      // Wheels
      for (let i=0;i<3;i++){
        const wx = x + i*w*0.05;
        ctx.fillStyle = '#1f2937';
        ctx.beginPath(); ctx.arc(wx, y, h*0.035, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#94a3b8';
        ctx.beginPath(); ctx.arc(wx, y, h*0.016, 0, Math.PI*2); ctx.fill();
      }

      // Body
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(x - w*0.01, y - h*0.12, w*0.16, h*0.1);
      // Boiler
      ctx.fillStyle = '#374151';
      ctx.beginPath(); ctx.roundRect(x + w*0.05, y - h*0.16, w*0.1, h*0.08, 12);
      ctx.fill();
      // Face window
      ctx.fillStyle = '#fef08a';
      ctx.beginPath(); ctx.arc(x + w*0.02, y - h*0.07, h*0.03, 0, Math.PI*2); ctx.fill();
      // Smile
      ctx.strokeStyle = '#1f2937'; ctx.lineWidth = h*0.005;
      ctx.beginPath(); ctx.arc(x + w*0.02, y - h*0.06, h*0.02, 0.2*Math.PI, 0.8*Math.PI); ctx.stroke();
      // Chimney smoke puff
      const puffY = y - h*0.2 - Math.sin(performance.now()/300)*h*0.01;
      ctx.fillStyle = 'rgba(120,144,156,0.4)';
      ctx.beginPath(); ctx.arc(x + w*0.1, puffY, h*0.025, 0, Math.PI*2); ctx.fill();

      // Cannon (rotates toward pointer)
      const ang = Math.atan2(gameState.pointer.y - cannonY, gameState.pointer.x - cannonX);
      ctx.save();
      ctx.translate(cannonX, cannonY);
      ctx.rotate(ang);
      ctx.fillStyle = '#111827';
      ctx.fillRect(0, -h*0.01, w*0.07, h*0.02);
      ctx.restore();
    }

    function banner(text, color) {
      const w = canvas.width, h = canvas.height;
      ctx.save();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.85;
      const pad = 12 * (w/1280);
      ctx.fillRect(w*0.3, h*0.04, w*0.4, h*0.07);
      ctx.globalAlpha = 1;
      ctx.fillStyle = 'white';
      ctx.font = `${Math.round(h*0.045)}px/1.1 sans-serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, w*0.5, h*0.075);
      ctx.restore();
    }

    function overlay(alpha=0.4) {
      ctx.save();
      ctx.fillStyle = `rgba(15,23,42,${alpha})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
    }
    function bigText(t) {
      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${Math.round(canvas.height*0.08)}px/1.1 sans-serif`;
      ctx.fillText(t, canvas.width/2, canvas.height*0.4);
      ctx.restore();
    }
    function smallText(t) {
      ctx.save();
      ctx.fillStyle = '#e2e8f0';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${Math.round(canvas.height*0.035)}px/1.2 sans-serif`;
      ctx.fillText(t, canvas.width/2, canvas.height*0.48);
      ctx.restore();
    }

    // ------------------ Main Loop ------------------
    function loop(ts) {
      const dt = Math.min(0.033, (ts - lastFrame)/1000); // clamp to ~30fps max step
      lastFrame = ts;
      if (running) update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ------------------ Polyfill: roundRect for older browsers ------------------
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        this.beginPath();
        this.moveTo(x+rr, y);
        this.arcTo(x+w, y,   x+w, y+h, rr);
        this.arcTo(x+w, y+h, x,   y+h, rr);
        this.arcTo(x,   y+h, x,   y,   rr);
        this.arcTo(x,   y,   x+w, y,   rr);
        this.closePath();
      };
    }
  </script>
</body>
</html>
